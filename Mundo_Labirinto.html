<!doctype html>
<html>
   <head>
	
	<meta charset="utf-8">
	<title>Mundo do Labirinto</title>
	<link rel = "stylesheet" type="text/css" href = "./css/chronos_menu_black.css"/>
    <link rel="shortcut icon" type="image/x-icon" href="./nitlab.jpg"/>

	 <!-- scripts JavaScript que são utilizados para carregar bibliotecas e frameworks de criação de cenas 3D no navegador. -->
    <!-- Babylon.js # Depois verificar quais destes links são desnecessários--> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
    <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
    <script src="https://preview.babylonjs.com/ammo.js"></script>
    <script src="https://preview.babylonjs.com/cannon.js"></script>
    <script src="https://preview.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/earcut.min.js"></script>
    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
    <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
    <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>


    <!-- // do labirinto!!!! -->
    <!-- <script src="https://code.jquery.com/pep/0.4.0/pep.min.js"></script> -->
	<!-- <script src="https://cdn.babylonjs.com/babylon.js"></script> -->
	<!-- <script src="https://cdn.babylonjs.com/gui/babylon.gui.js"></script> -->
<!--	<script src="https://cdn.babylonjs.com/loaders/babylon.glTFFileLoader.js"></script>	-->
	<!-- <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script> -->
    
    <!-- <script src="https://cdn.babylonjs.com/loaders/dist/OBJ/objFileLoader.js"></script> -->
    
    <!-- <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script> -->
    
    <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
    
    <!-- MediaPipe.js -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>


	<script src="https://code.jquery.com/pep/0.4.0/pep.min.js"></script>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/gui/babylon.gui.js"></script>
<!--	<script src="https://cdn.babylonjs.com/loaders/babylon.glTFFileLoader.js"></script>	-->
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	<script src="./stages_301.js"></script>

	<style>
        html, body{
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #canvasPrimario{
            width: 100%;
            height: 100%;
            touch-action: none; /*# testar habilitando e ver se dá para controlar pelo celular*/
            /* color:rgb(255, 0, 255); 
            background-color:rgb(255, 0, 255); */
        }

        .divs{
            width: 100%;
            height: 100%;
        }

        .divFixed {
            background-color: transparent;
            /* color: transparent; */ 
            position: fixed;
            top: 0px;
            left: 5px;
            width: 15%;
            height: 15%;
        }

        .divHUD {
            background-color: red;
            position: fixed;
            top: 200px;
            left: 5px;
            width: 15%;
            height: 15%;
        }
        
         .clear{
             clear:both;
         }
    </style>

   </head>
   <body onLoad = "init()">
	<nav id="menu-wrap">
	    <ul id="menu">
            <!-- <li><a href="#">Instruções</a>
                <ul>
                    <li><a>"[OK] Controle com WASD.</a></li>
                    <li><a>"[OK] P: pausar/continuar o jogo"</a></li>
                    <li><a>"[OK] 1, 2, 3: alternar os modos de visão da camera\</a></li>
                    <li><a>"[O] M: ativar/Desativar trilha sonora</a></li>
                    <li><a>"[ ] E: Interagir (coletar, falar, apertar)"</a></li>
                    <li><a>"[ ] 1: Habilidade especial 1 (?)"</a></li>
                    <li><a>"[ ] 2: Habilidade especial 2 (?)"</a></li>
                </ul>
            </li> -->
        <!-- <li><a href="#">Velocidade</a>
        <ul>
            <li><a href="#" onclick = "slow()">Lenta</a></li>
            <li><a href="#" onclick = "medium()">Média</a></li>
            <li><a href="#" onclick = "fast()">Rápida</a></li>
        </ul>
        </li> -->
        <!-- <li><a href="#">Jogo</a>
        <ul>
            <li><a href="#" onclick = "again()">[Ok]Mesmo estágio</a></li> -->
            
            <!-- Está sobrecarregando a memória -->
            <!-- <li><a href="#" onclick = "init()">[O] Próximo estágio</a></li> 

            <li><a href="#" onclick = "window.location.reload()">[OK] Resetar tudo</a></li>
		</ul>
		</li> -->
	    </ul>
	</nav>

      <canvas id = "canvasPrimario"></canvas>
      
      <script type = "text/javascript">
	// "use strict"; // altera o comportamento de alguns scripts de forma a evitar erros comuns e aumentar a segurança do código.

var engine;
// Obtém um elemento canvas do DOM (Modelo de Objeto de Documento) com o id "canvasPrimario".
//  Este elemento canvas será utilizado para desenhar a cena 3D.
var canvas = document.getElementById("canvasPrimario");

var cena_Mundo; // Cena do labirinto
var cena_Tarefa; // Cena da tarefa
var camera;

// Elementos 3d-------------------------------------------------------------------
// Player
const player = 'assets/personagens/players/ybot.babylon';

// Personagens
// var NPC_Sig = "./assets/personagens/npc/3d_model_sci-fi.glb";
// var NPC_Sig = "./assets/animais/bird/bird_fly.glb";
// var NPC_Sig = "./assets/personagens/npc/bot1/sig.glb";
// var NPC_Sig = "./assets/personagens/npc/Homem_andando.glb";
var NPC_Sig = "./assets/animais/butterfly.glb";

// Portal
//spellDisk

// Item coletável
//yellowEnergyBall
// Asas
//Celula_energia
//Moeda_1

// COmemoração
// Baloon

// Reações
// Casca de banana
// ExplodingBarrel
// ufo


var enemy_data = "./assets/personagens/npc/Ghost_Night_Light_03.glb";

// Abelha
const abelha = './assets/animais/Bee.glb';
// const abelha = './assets/animais/Beija-flor.glb';

// Elementos de construções
// const towerURL = "assets/ambiente/tower/TowerHouse.obj";
// const labirinto = './assets/ambiente/labirinto_01.glb';
const labirinto = './assets/ambiente/labirinto/maze1.glb';
// const labirinto = './assets/ambiente/labirinto/maze2.obj';

// Carregue o labirinto como um objeto 3D
// const labirinto = BABYLON.OBJFileLoader.Load("assets/ambiente/labirinto/maze2.obj");

// Elementos de cena
var gltf_data_03 = "./assets/ambiente/poste_lamp.glb";

// Dimenssões do labirinto
var BLOCK_SIZE = 8;
var Maze_size_X = 0;			// The row size of stage.
var Maze_size_Y = 0;			// The vertical size of stage.
var Maze_size_Z = 0;			// The col size of stage.

// Objetivos a serem alcançados no labirinto
var Goal_x, Goal_y, Goal_z;
var Goal_flag = 0;


var walk_org = 1.3; // Altera a velocidade com que se move
var walk_step = 0.3;
var up_step = walk_step + 0.2;
var down_step = walk_step + 0.2

// Direções do personagem
var sul_dir = -90 / 180 * Math.PI; // (S) Direção para TRÁS
var norte_dir = 90 / 180 * Math.PI;  // (W) Direção para FRENTE
var direita_dir = 180 / 180 * Math.PI; // (D) Direção para DIREITA
var esquerda_dir = 0 / 180 * Math.PI;   // (A) Direção para ESQUERDA

// Direção inicial do player
var walk_dir = norte_dir;   

// Posição inicial do player
var x = 0;
var y = 0;
var z = 0;

var moveX = 0;
var moveY = 0;
var moveZ = 0;

var pos_row_00 = 0;
var pos_row_01 = 0;
var pos_row_02 = 0;
var pos_col_00 = 0;
var pos_col_01 = 0;
var pos_col_02 = 0;
var pos_vrt_00 = 0;
var pos_vrt_01 = 0;
var pos_vrt_02 = 0;

var limit = BLOCK_SIZE - 5;

var Offset_ObY = 0;
var Offset_Bobj = 200;

// Quantidades de caixas, elevadores e inimigos
var counter = -1;
var BOX_count = 0;
var ENEMY_count = 0;   
var Temp_count, Temp_count_02;

// Flags
var DOWN_flag = 0;
var Change_flag = 0;
var Move_flag = 0;
var BOX_move_flag = 0;


// Estágios
var Temp_Room = [];
var ROOM = [];

// Caixas
var BOX = [];
var BOX_X = [];
var BOX_Y = [];
var BOX_Z = [];
var Offset_BoxY = [];
var BOX_flag = [];
var Temp_BOX_x, Temp_BOX_y, Temp_BOX_z, Temp_BOX_m, Temp_BOX_n;

// Elevadores
var LIFTcube = [];
var LIFT_X = [];
var LIFT_Y = [];
var LIFT_Z = [];
var LIFT_YY = [];
var Offset_LIFTY = [];
var LIFT_count = 0;
var Temp_LIFT_x, Temp_LIFT_y, Temp_LIFT_z, Temp_LIFT_n;

// Inimigos
var ENEMY = [];
var Enemy_X = [];
var Enemy_Y = [];
var Enemy_Z = [];
var enemyX = [];
var enemyY = [];
var enemyZ = [];
var ENEMY_count = 0;


var Temp_DOWN, Temp_DOWN_02;


// SIG
// const sig = './assets/personagens/npc/sig.glb';

// Mentor
const mentor = './assets/personagens/npc/Old_Man_separado/Old_Man_convertido_separado.gltf';
// const mentor = './assets/personagens/npc/Homem_andando.fbx'; // Converter....
// const mentor = './assets/personagens/npc/Astronauta.glb';


// Outlier
// const outlier = './assets/personagens/npc/outlier.glb';

// NPC's
const emogi = './assets/itens/Carinha_Olhos.glb';

// Elementos da natureza
const cacto_1 = './assets/plantas/Cacto_1.glb';
const cacto_2 = './assets/plantas/Cacto_2.glb';
const macieira = './assets/plantas/Macieira.glb';
const pinheiro_nevado = './assets/plantas/Pinheiro Nevado.glb';
const bordo = './assets/plantas/Bordo.glb';
const folhas_caindo = './assets/plantas/Folhas_caindo.glb';
const pilha_folhas = './assets/plantas/Pilha de folhas.glb';

// Skyboxes 
const atmosfera = 'assets/skybox/TropicalSunnyDay';
// const atmosfera = 'assets/skybox/TropicalSunnyDay';


// Elementos sonoros--------------------------------------------------------------
var narrador = true; // checkbox
var som_Ambiente = false; // checkbox
var som_Efeitos = true; // checkbox

const Ambiente_Calmo = 'assets/sounds/soundtracks/Ambiente_Calmo_01.mp3';
// const Ambiente_Suspense = 'assets/sounds/soundtracks/Ambiente_Suspense.mp3';

var explosao = 'assets/sounds/effects/explosao.mp3';
var chuva = 'assets/sounds/effects/chuva.mp3';
var fogo = 'assets/sounds/effects/fogo.mp3';


//#checkbox 1ª ou 3ª pessoa
var firstPerson = false;

// Animações
var skeleton_Heroi = null; // utilizada para acessar e controlar o esqueleto do personagem.

var idleAnim = null;
var walkAnim = null;
var runAnim = null;
var sprintAnim = null;
var jumpAnim = null;

var animationBlend = 0.05; // controla a velocidade com que as animações são misturadas entre si.
var mouseSensitivity = 0.0005; // controla a sensibilidade do mouse ao mover a câmera.
var cameraSpeed = 0.0075; // controla a velocidade da câmera ao se mover pelo cenário.

// var idleSpeed = 0.1; // # Não utilizada
var walkSpeed = 0.001; // controla a velocidade do personagem ao andar pelo cenário.
var runSpeed = 0.005; // controla a velocidade do personagem ao correr pelo cenário.
var sprintSpeed = 0.008; // controla a velocidade do personagem ao sprintar pelo cenário.
var jumpSpeed = 0.1; // controla a velocidade do personagem ao pular.
var jumpHeight = 0.5; //  controla a altura do salto do personagem.
// o que significa que a gravidade é de 0 na direção X, -0.5 na direção Y e 0 na direção Z.
//  Isso significa que o personagem cairá para baixo (na direção Y negativa) 
// com uma força de gravidade de 0.5.
var gravity = new BABYLON.Vector3(0, -0.5, 0);

// Variáveis alteradas no jogo
var speed = 0; // velocidade atual do personagem. O personagem está parado no início do jogo.
var vsp = 0; // velocidade vertical do personagem. O personagem não está subindo ou descendo no início do jogo.
var jumped = false; // indica se o personagem está saltando ou não.
var mouseX = 0, mouseY = 0; // coordenadas atuais do mouse.
var mouseMin = -35, mouseMax = 45; // limites mínimo e máximo de rotação da câmera em torno do eixo X.

    // Executa o mesmo labirinto novamente
function again() {
    counter = counter - 1;
    init();
}

function init() {
	if(counter >= 0) {
	    cena_Mundo.clearCachedVertexData();
	    cena_Mundo.cleanCachedTextureBuffer();
	    // cena_Mundo.dispose();// Limpe os recursos da cena antes de reiniciar
	    // engine.dispose();
	}
	counter = counter + 1;
    x = 0;
    y = 0;
    z = 0;
	Goal_flag = 0;
	BOX_count = 0;
	LIFT_count = 0;
	ENEMY_count = 0;
	Offset_ObY = 0;
	Temp_BOX_x = 0;
	Temp_BOX_y = 0;
	Temp_BOX_z = 0;
	Temp_BOX_m = -1;
	Temp_BOX_n = -1;
	Temp_DOWN = -1;
	Temp_DOWN_02 = -1;
	Temp_LIFT_x = 0;
	Temp_LIFT_y = 0;
	Temp_LIFT_z = 0;
	Temp_LIFT_n = -1;
	Temp_count = -1;
	Temp_count_02 = -1;
	DOWN_flag = 0;
	Move_flag = 0;
	BOX_move_flag = 0;
	BOX = [];
	Offset_BoxY = [];
	BOX_flag = [];
	LIFTcube = [];
	LIFT_X = [];
	LIFT_Y = [];
	LIFT_Z = [];
	LIFT_YY = [];
	Offset_LIFTY = [];
	BOX_X = [];
	BOX_Y = [];
	BOX_Z = [];
	ENEMY = [];
	Enemy_X = [];
	Enemy_Y = [];
	Enemy_Z = [];
	if(counter >= room.length) {
	    counter = 0;
	}
	ROOM = room[counter];
	Maze_size_Y = ROOM.length;
	Maze_size_X = ROOM[0].length;
	Maze_size_Z = ROOM[0][0].length;
	for(var k = 0; k < Maze_size_Y + 4; k++) {
	    Temp_Room[k] = [];
	    for(var i = 0; i < Maze_size_X + 4; i++) {
		    Temp_Room[k][i] = [];
            for(var j = 0; j < Maze_size_Z + 4; j++) {
                Temp_Room[k][i][j] = "F";
            }
	    }
	}
	for(var k = 0; k < Maze_size_Y; k++) {
	    for(var i = 0; i < Maze_size_X; i++) {
            for(var j = 0; j < Maze_size_Z; j++) {
                Temp_Room[k + 2][i + 2][j + 2] = ROOM[k][i].substr(j,1)
            }
	    }
	}
        engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
        
        cena_Mundo = cria_Mundo();

        // cena_Tarefa = cria_Tarefa();
        
        var cena_Ativa = cena_Mundo;
            engine.runRenderLoop(function () {
                cena_Ativa.render();
        });
        engine.runRenderLoop(function() {
	        cena_Mundo.render();
        });
    }

	var cria_Mundo = function () {
    
    // Faz com que o motor de renderização baixe todos os recursos necessários 
    // para a cena 3D e os armazene localmente, permitindo que a cena seja renderizada 
    // mesmo quando o usuário estiver offline.
    engine.enableOfflineSupport = false;
    // engine.enableOfflineSupport = true;

    // Utilizado para decomposeLerp e interpolação de matrizes
    // BABYLON.Animation.AllowMatricesInterpolation = true;
    
    // // Animação de Carregando
    // engine.displayLoadingUI();
    
    // Cria a cena do MUNDO
    cena_Mundo = new BABYLON.Scene(engine);

    // Cria a cena da TAREFA
    cena_Tarefa = new BABYLON.Scene(engine);

	// NEBLINA: útil para esconder os limites do cenário e dar uma sensação de distância.
    cena_Mundo.fogEnabled = false; // desabilitada
    cena_Mundo.fogMode = BABYLON.Scene.FOGMODE_EXP2; // tipo de neblina
	cena_Mundo.fogDensity = 0.01; // densidade da neblina
    cena_Mundo.fogColor = new BABYLON.Color3(0.8, 0.9, 1.0); // cor da neblina
    cena_Mundo.clearColor = cena_Mundo.fogColor; // A cor de limpeza da cena (a cor que é usada para limpar a tela a cada frame)

// Camera
    //  camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 4, 10, new BABYLON.Vector3(0, 0, 30), cena_Mundo);	  
    camera = new BABYLON.ArcRotateCamera("Camera", 0/180*Math.PI, 30/180*Math.PI, 10, new BABYLON.Vector3(0, 8, 0), cena_Mundo);
    camera.setPosition(new BABYLON.Vector3((BLOCK_SIZE * Maze_size_X / 2 * -1) - 40, BLOCK_SIZE * 16, (BLOCK_SIZE * Maze_size_Z / 2 * -1) + 12));
    // camera.setPosition(new BABYLON.Vector3(100, 4, -100));

	cena_Mundo.activeCamera = camera;
    // cena_Mundo.activeCamera.attachControl(canvas, true);// para usar o scrool deve estar habilitada

    camera.lowerRadiusLimit = 5; // Limite de zoom in
    camera.upperRadiusLimit = 100; // Limite de zoom out
    camera.wheelDeltaPercentage = 0.01; // Velocidade do zoom do mouse
    // camera.radius = 30;
	// camera.inputs.clear();

	if (som_Ambiente)
        var music = new BABYLON.Sound("Ambiente_Calmo", Ambiente_Calmo, cena_Mundo, null, { loop: true, autoplay: true });

	//------------------------------- Cria o plano do chão ----------------------------------
	// var groundSize = 150;
    // var ground = BABYLON.Mesh.CreateGround("ground", groundSize, groundSize, 5, cena_Mundo);
    // ground.position.y = -7;

    // Cria a textura do chão
    // var grade = new BABYLON.GridMaterial("grade", cena_Mundo);
    // grade.gridRatio = 1;
    // // grade.lineColor = new BABYLON.Color3.White();
    // // grade.mainColor = new BABYLON.Color3.Black();
    // // grade.alpha = 0.3;
    // // grade.majorUnitFrequency = 10;    
    // // ground.fogEnabled = true;
    // ground.material = grade;
    // ground.visibility = false; //Oculta o elemento

	// Cria uma repetição do material 
    // var texturaNitLab = new BABYLON.StandardMaterial("nitlab", cena_Mundo);
    // texturaNitLabw.diffuseTexture = new BABYLON.Texture("assets/textures/flare.png", cena_Mundo);
    // // texturaNitLab.diffuseTexture.uScale = 2.0;//Repeat 2 times on the Vertical Axes
    // texturaNitLab.diffuseTexture.vScale = 5.0;//Repeat 5 times on the Horizontal Axes
    // texturaNitLab.backFaceCulling = false;//Always show the front and the back of an element
    // ground.material = texturaNitLab;
	
		// Ground
	    var groundMaterial = new BABYLON.StandardMaterial("ground", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/Box_07.png", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/floor.png", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/floor4.jpg", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/grass.jpg", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/grass.png", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/ground_2.jpg", cena_Mundo);
        groundMaterial.diffuseTexture = new BABYLON.Texture("textures/ice_05.png", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/rockyGround_basecolor.png", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/sand.jpg", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/albedo.png", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/wood.jpg", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/nebula/nebula_nx.jpg", cena_Mundo);
        // groundMaterial.diffuseTexture = new BABYLON.Texture("textures/add/masonry-wall-texture.jpg", cena_Mundo);
		groundMaterial.diffuseTexture.uScale = Maze_size_X;
		groundMaterial.diffuseTexture.vScale = Maze_size_Z;
		groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);

	    var ground = BABYLON.Mesh.CreateGround("ground", (Maze_size_X + 2) * BLOCK_SIZE, (Maze_size_Z + 2) * BLOCK_SIZE, 1, cena_Mundo, false);
		ground.material = groundMaterial;
		ground.position.y = BLOCK_SIZE * 2;
		ground.checkCollisions = true;
        ground.receiveShadows = true;

// Lights
        var light0 = new BABYLON.DirectionalLight('light00', new BABYLON.Vector3(3000, -10000, 5000), cena_Mundo);
		light0.position = new BABYLON.Vector3(0, 100, 0);
		light0.intensity = 1.0;

	    var light1 = new BABYLON.DirectionalLight("light01", new BABYLON.Vector3(1000, 1000, -1000), cena_Mundo);
		light1.position = new BABYLON.Vector3(0, 1000, 1000);
		light1.intensity = 2.0;

	    var light2 = new BABYLON.PointLight("light02", new BABYLON.Vector3(0, 1000, 0), cena_Mundo);
		light2.range = 100;
		light2.parent =  bulb;

	    var light4 = new BABYLON.HemisphericLight("light04", new BABYLON.Vector3(0, 100, 0), cena_Mundo);
		light4.position = new BABYLON.Vector3(0, 1000, 1000);
		light4.intensity = 0.5;

	    var shadowGenerator = new BABYLON.ShadowGenerator(1024, light0);

// Mão como cursor
        // Imagem de mão como cursor
        // var hand = BABYLON.MeshBuilder.CreatePlane("hand", {width: 2, height: 2}, cena_Mundo);
        // var handMaterial = new BABYLON.StandardMaterial("handMaterial", cena_Mundo);
        // handMaterial.diffuseTexture = new BABYLON.Texture("assets/gui/hand3.png", cena_Mundo);
        // hand.material = handMaterial;
        
        // // Configure the interaction with the hand image:
        // var handPointer = new BABYLON.DefaultCursor("handPointer", cena_Mundo);
        // handPointer.hoverCursor = "pointer";
        // handPointer.activate();
        
        // // Handle mouse events:
        // hand.onPointerMoveObservable.add(function (event) {
        //     // Handle the mouse movement
        // });
        // hand.onPointerDownObservable.add(function (event) {
        //     // Handle the mouse click
        // });
        
        // // Add the cursor functionality:
        // hand.isPickable = true;
        // hand.cursor = handPointer;



 //tps ???
    const dsm = new BABYLON.DeviceSourceManager(engine);
    var deltaTime = 0;


    //character nodes ???
    var main = new BABYLON.Mesh("parent", cena_Mundo);
    // Posição do player
    main.position = new BABYLON.Vector3(x, y, z);
    
    var target = new BABYLON.TransformNode();

    // Posição do personagem
    var character = new BABYLON.Mesh("character", cena_Mundo);
    character.position = new BABYLON.Vector3(0, 16, 0);    

    // Configurações da camera
    var firstPersonCamera = {
        middle: {
            position: new BABYLON.Vector3(0, 1.75, 0.25),
            fov: 1.25, // # ??
            mouseMin: -45,
            mouseMax: 45
        },
        far: {
            position: new BABYLON.Vector3(0, 15, 0.25),
            fov: 1.5,
            mouseMin: -5,
            mouseMax: 45
        }
    };

    var thirdPersonCamera = {
        middle: {
            position: new BABYLON.Vector3(0, 1.35, -5),
            fov: 0.8,
            mouseMin: -5,
            mouseMax: 45
        },
        leftRun: {
            position: new BABYLON.Vector3(0.7, 1.35, -4),
            fov: 0.8,
            mouseMin: -35,
            mouseMax: 45
        },
        rightRun: {
            position: new BABYLON.Vector3(-0.7, 1.35, -4),
            fov: 0.8,
            mouseMin: -35,
            mouseMax: 45
        },
        far: {
            position: new BABYLON.Vector3(0, 4, -6),
            fov: 1.5,
            mouseMin: -5,
            mouseMax: 45
        }
    };

    function switchCamera(type){
        camera.position = type.position.divide(camera.parent.scaling);
        camera.fov = type.fov;
        mouseMin = type.mouseMin,
        mouseMax = type.mouseMax
    }

    // Animação de Carregando
    engine.displayLoadingUI();

	// Carrega o Player
    BABYLON.SceneLoader.ImportMesh("", "", player, cena_Mundo, function (mesh_Heroi, particleSystems, skeletons_Heroi){
        skeleton_Heroi = skeletons_Heroi[0];

        var body = mesh_Heroi[1];
		body.scaling = new BABYLON.Vector3(0.04, 0.04, 0.04);
        body.rotation.y = BABYLON.Tools.ToRadians(180);
        body.checkCollisions = true;
        body.collisionsEnabled = true;

        var joints = mesh_Heroi[0];
        joints.parent = body;
        joints.checkCollisions = true;
        joints.collisionsEnabled = true;

        body.parent = character;    

        character.checkCollisions = true; // NAO FAZ DIFERENÇA
        character.collisionsEnabled = true; // NAO FAZ DIFERENÇA

        // Textura do corpo do Player
        body.material = new BABYLON.StandardMaterial("character", cena_Mundo);
        body.material.diffuseColor = new BABYLON.Color3.Blue();// Cor
        // body.material.specularColor = BABYLON.Color3.White(); // Reflexo
        // body.material.emissiveColor = new BABYLON.Color3.Red();

        // body.material.ambientColor = new BABYLON.Color3.Blue();

        // body.material.alpha = 0.8;
        // body.material.wireframe = true;

        // Textura das juntas do Player
        joints.material = new BABYLON.StandardMaterial("joints", cena_Mundo);
        joints.material.emissiveColor = BABYLON.Color3.Green();
        joints.material.specularColor = BABYLON.Color3.Blue();
        // joints.material.alpha = 0.5;

        // Sombras no player
        shadowGenerator.addShadowCaster(character);
        shadowGenerator.getShadowMap().renderList.push(character);

        // Animações do player
        var idleRange = skeleton_Heroi.getAnimationRange("None_Idle");
        var walkRange = skeleton_Heroi.getAnimationRange("None_Walk");
        var runRange = skeleton_Heroi.getAnimationRange("None_Run");
        var sprintRange = skeleton_Heroi.getAnimationRange("None_Sprint");
        var jumpRange = skeleton_Heroi.getAnimationRange("None_Jump");

        // if (idleRange) {
        //     cena_Mundo.beginAnimation(skeleton_Heroi, idleRange.from, idleRange.to, true);

        //     // Rotaciona a camera orbitando o herói
        //     // cena_Mundo.activeCamera.useAutoRotationBehavior = true;
        // }

        idleAnim = cena_Mundo.beginWeightedAnimation(skeleton_Heroi, idleRange.from+1, idleRange.to, 1.0, true);
        walkAnim = cena_Mundo.beginWeightedAnimation(skeleton_Heroi, walkRange.from+1, walkRange.to, 0, true);
		runAnim = cena_Mundo.beginWeightedAnimation(skeleton_Heroi, runRange.from+1, runRange.to, 0, true);
        sprintAnim = cena_Mundo.beginWeightedAnimation(skeleton_Heroi, sprintRange.from+1, sprintRange.to, 0, true);
        jumpAnim = cena_Mundo.beginWeightedAnimation(skeleton_Heroi, jumpRange.from+1, jumpRange.to, 0, true);
		
        main.checkCollisions = false;  
        character.parent = main;
        target.parent = main;
        
        // Alterna a camera de acordo com a opção escolhida
        if (firstPerson == true){
            camera.parent = character;
            switchCamera(firstPersonCamera.middle); // Centralizado
            // switchCamera(firstPersonCamera.far); // Distante
        }else{
            camera.parent = target;
            // switchCamera(thirdPersonCamera.leftRun); // Lado esquerdo
            // switchCamera(thirdPersonCamera.rightRun);// Lado direito
            switchCamera(thirdPersonCamera.middle);     // Centralizado
            // switchCamera(thirdPersonCamera.far);     // Distante
        }


        // # Procurar o lcoal correto para isso.  Oculta a animação de carregando
        engine.hideLoadingUI();


        // Interação com Player usando a mão
        // control_Player(skeleton_Heroi, cena_Mundo);
        // var mesh_Heroi = mesh_Heroi[1]; // #Tirar!!!


        // var t = 0; // ?
        // var j = 0; // Vetor com os pontos dos dedos
        // var novoValor = 0;// ?
        
        // pegar = function(p){
        //     j = p; 
        // };
        
        // // 4: polegar, 8: indicador, 12: maior de todos, 20: mindinho, 16: anelar
        // // pq multiplica por 5? escala??
        // // Usar o 4 para mover na horizontal (DESVIAR)
        // // Usar o 8 para mover na vertical (SALTAR)
        // // Usar o 12 para olhar para cima e baixo
        // // Usar o 20 para  olhar para esquerda e direita
        // // Usar o 16 para dar zoom da tela

        // cena_Mundo.beforeRender = function(){
        //     // t += .1;
        //     if(j != 0){// pq verificar se é diferente de zero?
        //         //mesh_Heroi.rotation = new BABYLON.Vector3(0, 0, j[4].x * (5));//z
        //         // mesh_Heroi.position = new BABYLON.Vector3(0, 0, j[4].x * (5));//z
        //         // mesh_Heroi.position = new BABYLON.Vector3(0, j[4].y*(-0.5) + 0.5, 0);//y (saltar quando mover para cima)
        //         // mesh_Heroi.position = new BABYLON.Vector3(j[4].x * (5), 0, 0);//x (desloca ao mover horizontalmente)
        //         // mesh_Heroi.position = new BABYLON.Vector3(j[4].x*(6), 0, 0);//x (desloca ao mover horizontalmente)

        //         // mesh_Heroi.position = new BABYLON.Vector3(j[4].x*(3), j[8].y * 0.4, 0);
                            
                
        //         //# Habilitar o zoom para funcionas apenas com a mão esquerda!!!!!!!!!!
        //         // camera.position = new BABYLON.Vector3(1, 1.5, j[12].z * -60); // zoom quando aproxima ou afasta o dedo
                
        //         // 0: Pulso
        //         // camera.position = new BABYLON.Vector3(1, 1.5, j[0].z * -60); // zoom quando aproxima ou afasta o dedo


        //         console.log("j: ",j);
        //         console.log("j[4].x: ",j[4].x);
        //         console.log("j[8].y: ",j[8].y);
        //     }
        // };

        // Interação com Camera usando a mão
        // control_Player(Camera, cena_Mundo);
        // mesh_Heroi = mesh_Heroi[1];
                
        // var j = 0;
        
        // pegar = function(p){
        //     j = p; 
        // };
        
        // // 12: maior de todos, 20: mindinho, 16: anelar
        // // Usar o 12 para olhar para cima e baixo
        // // Usar o 20 para  olhar para esquerda e direita
        // // Usar o 16 para dar zoom da tela

        // cena_Mundo.beforeRender = function(){
        //     if(j != 0){// pq verificar se é diferente de zero?
        //         // main.position = new BABYLON.Vector3(j[12].x, j[20].y, j[16].z);
        //        // camera.position = new BABYLON.Vector3(j[12].x, j[20].y, j[16].z);
        //     //    camera.position = new BABYLON.Vector3(j[12].x * 5, 5, 10);
        //     // camera.position = new BABYLON.Vector3(0, j[12].y *4 , 10);
        //     camera.position = new BABYLON.Vector3(1, 1.5, j[12].z * -60); // zoom quando aproxima ou afasta o dedo
            
        //     // move o player junto com a camera
        //     // main.position = new BABYLON.Vector3(1, 1.5, j[12].z * -60); // zoom quando aproxima ou afasta o dedo
            
            
        //         console.log("j[12].x: ",j[12].x);
        //         console.log("j[20].y: ",j[20].y);
        //         console.log("j[16].z: ",j[16].z);
        //     }
        // };

        
        
        
        // Fazer player mover para local do clique

//         cena_Mundo.registerBeforeRender(function (){
// // Obtém a malha do personagem
// // var character = cena_Mundo.getMeshByName("character");
// // var event;
// // Adiciona um evento de clique do mouse à cena
// cena_Mundo.onPointerObservable.add(function(event) {
//   // Verifica se o evento é um clique do mouse
//   if (event !== null && event !== undefined && event.type === BABYLON.PointerEventTypes.POINTERDOWN) {
//     // Obtém a posição do clique na tela
//   //  var clickPos = event.pointer.position;
//     // Imprime a posição do clique na tela
//     // console.log("Posição do clique: (" + clickPos.x + ", " + clickPos.y + ")");

//     // Converte a posição do clique para coordenadas de mundo
//     // var clickWorldPos = BABYLON.Vector3.Unproject(
//     //   new BABYLON.Vector3(clickPos.x, clickPos.y, 0),
//     //   cena_Mundo.getEngine().getRenderWidth(),
//     //   cena_Mundo.getEngine().getRenderHeight(),
//     //   BABYLON.Matrix.Identity()
//     // );

//     // Atualiza a posição do personagem para a posição do clique
//     body.position.x = 0;
//     joints.position.y += 0.01;
//     body.position.z = 0;

//     //main: move a camera e player juntos
//     //target: move a camera 
//     //body/character: move o player
//   }
// });
        // });
        // //# Adiciona o LABIRINTO!!
        // BABYLON.SceneLoader.ImportMesh("", "", labirinto, cena_Mundo, function (mesh_Labirinto){
        //     const Labirinto = mesh_Labirinto[0];

        //     // labirinto = BABYLON.Mesh.MergeMeshes([mesh_Labirinto, box]);
        //     // mesh_Labirinto[0].scaling = new BABYLON.Vector3(10, 1, 1);
        //     // mesh_Labirinto[0].position = new BABYLON.Vector3(0, 5.1, 0);
        //     // // addToMirror(mesh_Labirinto);
        //     // // addShadows(mesh_Labirinto);
        //     mesh_Labirinto.collisionsEnabled = true;
        //     mesh_Labirinto.checkCollisions = true;

    //         // Adicione colisão ao personagem
    // player.addPhysics(null, BABYLON.PhysicsEngine.BoxImpostor, { mass: 1, restitution: 0.5 });
    
            // Adicione um componente de física às paredes do labirinto
            // Labirinto.addPhysics(null, BABYLON.PhysicsEngine.BoxImpostor, { mass: 0, restitution: 0.9 });
        // });

});

// Adiciona a ABELHA
        // var abelha = null;
    //     BABYLON.SceneLoader.ImportMesh("", "", abelha, cena_Mundo, function (mesh_Bee, particleSystems, skeletons_Bee) {
    //         mesh_Bee[0].scaling = new BABYLON.Vector3(0.8, 0.8, 0.8);
    //         mesh_Bee[0].position = new BABYLON.Vector3(0, 19, 0);

    //         mesh_Bee[0].collisionsEnabled = true;
    //         mesh_Bee[0].wireframe = true;


    //         // Elipse para verificar as colisões
    //         // mesh_Bee[0].ellipsoid = new BABYLON.Vector3(9, 8, 8);
    //         // mesh_Bee[0].ellipsoidOffset = new BABYLON.Vector3(0, 0, 0);
    //         mesh_Bee[0].checkCollisions = true;

    //         // Exibe a elipse que envolve a abelha
    //         // drawEllipsoid(mesh_Bee[0]);

    //         // skeleton_Bee = skeletons_Bee[];

    //         // var flyBee = skeleton_Bee.getAnimationRange("fly");
    //         // flyBee_Anim = cena_Mundo.beginWeightedAnimation(skeleton_Bee, flyBee.from, flyBee.to, 0, true);

    //         // flyBee_Anim;
    // }); 


    // Determina as teclas das ações
    cena_Mundo.registerBeforeRender(function(){
        deltaTime = engine.getDeltaTime();

        // updateCamera();
        // updateCameraPipe();
        
        if (character != null){
            var keyboard = dsm.getDeviceSource(BABYLON.DeviceType.Keyboard);
            var mouse = dsm.getDeviceSource(BABYLON.DeviceType.Mouse);
            if (keyboard){
                if (firstPerson == true){
                    firstPersonMovement(
                        keyboard.getInput(87), //W
                        keyboard.getInput(83), //S
                        keyboard.getInput(65), //A
                        keyboard.getInput(68), //D
                        keyboard.getInput(16), //Shift
                    );
                }else{
                    thirdPersonMovement(
                        keyboard.getInput(87), //W
                        keyboard.getInput(83), //S
                        keyboard.getInput(65), //A
                        keyboard.getInput(68), //D
                        keyboard.getInput(32), //Space
                        keyboard.getInput(16), //Shift
                    );
                }
            }
        }
    });

	// // Movimentação do mouse
    // var mouseMove = function(e){
    //     var movementX = e.movementX ||
    //             e.mozMovementX ||
    //             e.webkitMovementX ||
    //             0;

    //     var movementY = e.movementY ||
    //             e.mozMovementY ||
    //             e.webkitMovementY ||
    //             0;
        
    //     mouseX += movementX * mouseSensitivity * deltaTime;
    //     mouseY += movementY * mouseSensitivity * deltaTime;
    //     mouseY = clamp(mouseY, mouseMin, mouseMax);
    // }


    // function updateCamera(){
    //     target.rotation = lerp3(
    //         target.rotation, 
    //         new BABYLON.Vector3(
    //             BABYLON.Tools.ToRadians(mouseY),
    //             BABYLON.Tools.ToRadians(mouseX), 0
    //             // BABYLON.Tools.ToRadians(target.rotation.x),
    //             // BABYLON.Tools.ToRadians(target.rotation.y), 0
    //         ), cameraSpeed*deltaTime
    //     );
    // }


    // function updateCamera(){
    //     main.rotation = lerp3(
    //         main.rotation, 
    //         new BABYLON.Vector3(
    //             BABYLON.Tools.ToRadians(mouseY),
    //             BABYLON.Tools.ToRadians(mouseX), 0
    //             // BABYLON.Tools.ToRadians(target.rotation.x),
    //             // BABYLON.Tools.ToRadians(target.rotation.y), 0
    //         ), cameraSpeed*deltaTime
    //     );
    // }



    // function updateCameraPipe(){
    //     target.rotation = lerp3(
    //         target.rotation, 
    //         new BABYLON.Vector3(dedo, dedo, 0), 
    //         cameraSpeed*deltaTime
    //     );
    // }

 // Movimentação em 3ª pessoa
 function thirdPersonMovement(up, down, left, right, jump, run){
    var directionZ = up-down;
    var directionX = right-left;

    var vectorMove = new BABYLON.Vector3.Zero();
    var direction = Math.atan2(directionX, directionZ);

    var currentState = idleAnim;
    

    //move
    if (directionX != 0 || directionZ != 0){ // Se o player estiver se movendo
        if (run != 1){ // Andando
            currentState = runAnim;
            speed = lerp(speed, runSpeed, runAnim.weight);
        }else{         // Correndo
            currentState = sprintAnim;
            speed = lerp(speed, sprintSpeed, sprintAnim.weight);
        }

        // Move o player nas 4 direções (OK) 
        var rotation = (target.rotation.y+direction) % 360;
        character.rotation.y = lerp(
            character.rotation.y, rotation, 0.25
        );
        
        // # Move a camera para parte de trás do player (Bug)
        //  var rotation = (target.rotation.y+direction) % 360;
        // main.rotation.y = lerp(
        //     main.rotation.y, rotation, 0.25
        // );
        
        // Anda no solo // # Não fez diferença
        vectorMove = new BABYLON.Vector3(
            (Math.sin(rotation)), 0,
            (Math.cos(rotation))
        );

    }else{
        currentState = idleAnim;
        speed = lerp(speed, 0, 0.001);
        // speed = lerp(idleSpeed, 0, 0.001);
    }

    //jump # Bug, não volta ao normal
    if (jump == 1 && jumped == false){
        jumped = true;
    }
    if (jumped == true){
        if (vsp < jumpHeight){
            vsp += jumpHeight/10;
        }else{
            vsp += gravity.y/10;
            vsp = Math.min(vsp, gravity.y);
            if (vsp == gravity.y){
                // vsp = gravity.y;
                jumped = false;
            }
        }
        var puloRange = skeleton_Heroi.getAnimationRange("None_Jump");
        var a = cena_Mundo.beginAnimation(skeleton_Heroi, puloRange.from+1, puloRange.to, false, 1, function(){
            jumped = false;
            // console.log("stopped "+puloRange.from+1+" "+puloRange.to);
        });
    }else{
        // cena_Mundo.beginAnimation(skeleton_Heroi, idleRange.from+1, idleRange.to, false, 1);
        // currentState = idleAnim;
        // speed = lerp(speed, 0, 0.001);
        // speed = lerp(speed, idleAnim, idleAnim.weight);
        vsp = gravity.y;
    }

    // var m = vectorMove.multiply(new BABYLON.Vector3().setAll( speed*deltaTime ));
    // main.moveWithCollisions( m.add(new BABYLON.Vector3(0, vsp, 0)) ); // se pular, cai 
    // main.moveWithCollisions( m.add(new BABYLON.Vector3(0, 0, 0)) );// pula, mas não volta para andar normalmente
    
    switchAnimation(currentState);
    // console.log("Estado atual: ", currentState);
}

    // Movimentação em 1ª pessoa
    // function firstPersonMovement(up, down, left, right, run){
    //     var directionZ = up-down;
    //     var directionX = right-left;

    //     var vectorMove = new BABYLON.Vector3.Zero();
    //     var direction = Math.atan2(directionX, directionZ);

    //     var currentState = idleAnim;


    //     if (directionX != 0 || directionZ != 0){
    //         if (up == 1){
    //             if (run != 1){
    //                 currentState = walkAnim;
    //                 speed = lerp(speed, walkSpeed, walkAnim.weight);
    //             }else{
    //                 currentState = runAnim;
    //                 speed = lerp(speed, runSpeed, runAnim.weight);
    //             }
    //         }else{ // Desnecessário
    //             currentState = "walk";
    //             speed = lerp(speed, walkSpeed, walkAnim.weight);
    //         }

    //         vectorMove = new BABYLON.Vector3(
    //             (Math.sin( (target.rotation.y + direction) - BABYLON.Tools.ToRadians(180) )), 0,
    //             (Math.cos( (target.rotation.y + direction) - BABYLON.Tools.ToRadians(180) ))
    //         );
    //     }

    //     character.rotation.y = target.rotation.y - BABYLON.Tools.ToRadians(180);
    //     camera.rotation.x = target.rotation.x;

    //     var m = vectorMove.multiply(new BABYLON.Vector3().setAll( speed*deltaTime ));
    //     main.moveWithCollisions( m.add(gravity) );

    //     switchAnimation(currentState);
    // }



    // Alterna entre diferentes animações em um personagem ou modelo 3D. 
    // Ela recebe um parâmetro anim que é a animação para a qual deve mudar.
    // A função cria um array de animações chamado anims que armazena as animações
    //  idleAnim, runAnim, walkAnim e sprintAnim. 
    // Em seguida, ela itera sobre cada animação no array e atualiza o peso 
    // de cada animação de acordo com a animação passada como parâmetro. 
    // Se a animação atual for igual a anim, o peso da animação é aumentado 
    // usando a variável animationBlend e o delta time. Se não, o peso da animação 
    // é diminuído usando a mesma variável e o delta time.
    // Por fim, o peso de cada animação é limitado a um intervalo de 0 a 1 usando 
    // a função clamp. Isso garante que o peso de cada animação não exceda o 
    // intervalo permitido e evita erros.
    function switchAnimation(anim){
        var anims = [idleAnim, runAnim, walkAnim, sprintAnim];
        
        if (idleAnim != undefined){
            for (var i=0; i<anims.length; i++){
                if (anims[i] == anim){
                    anims[i].weight += animationBlend * deltaTime;
                }else{
                    anims[i].weight -= animationBlend * deltaTime;
                }

                anims[i].weight = clamp(anims[i].weight, 0.0, 1.0);
            }
        }
    }

    // Limita um valor a um intervalo específico, retornando o valor máximo 
    //se o valor for maior do que o máximo, o valor mínimo se o valor for menor 
    //do que o mínimo, e o próprio valor se estiver no intervalo. 
    function clamp(value, min, max){
        return (Math.max(Math.min(value, max), min));
    }

    // Retorna um valor interpolado entre um início e um fim, 
    // com base em uma velocidade específica
    function lerp(start, end, speed){
        return (start + ((end - start) * speed));
    }

    // Faz uma interpolação linear entre dois vetores 3D 
    // usando as funções lerp e BABYLON.Vector3.
    function lerp3(p1, p2, t){
        var x = lerp(p1.x, p2.x, t);
        var y = lerp(p1.y, p2.y, t);
        var z = lerp(p1.z, p2.z, t);

        return new BABYLON.Vector3(x, y, z);
    }

	// Trava o mouse
    // Configure all the pointer lock stuff
    function setupPointerLock(){
        // register the callback when a pointerlock event occurs
        document.addEventListener('pointerlockchange', changeCallback, false);
        document.addEventListener('mozpointerlockchange', changeCallback, false);
        document.addEventListener('webkitpointerlockchange', changeCallback, false);

        // when element is clicked, we're going to request a pointerlock
        canvas.onclick = function(){
            canvas.requestPointerLock = 
                canvas.requestPointerLock ||
                canvas.mozRequestPointerLock ||
                canvas.webkitRequestPointerLock
            ;

            // Ask the browser to lock the pointer
            canvas.requestPointerLock();
        };

    }


    // called when the pointer lock has changed. Here we check whether the
    // pointerlock was initiated on the element we want.
    function changeCallback(e) {
        if (document.pointerLockElement === canvas ||
            document.mozPointerLockElement === canvas ||
            document.webkitPointerLockElement === canvas
        ){
            // we've got a pointerlock for our element, add a mouselistener
            document.addEventListener("mousemove", mouseMove, false);
        } else {
            // pointer lock is no longer active, remove the callback
            document.removeEventListener("mousemove", mouseMove, false);
        }
    };

    // Trava o ponteiro do mouse
//    setupPointerLock();

 // Constrói elementos do cenário
    var box = BABYLON.MeshBuilder.CreateBox("box", {size: 10}, cena_Mundo);
    box.position = new BABYLON.Vector3(15, 20, 2);
    box.material = new BABYLON.StandardMaterial("materialGround", cena_Mundo);
    // box.material.emissiveColor = new BABYLON.Color3.Blue();
    box.material.diffuseColor = new BABYLON.Color3.Red();
    box.material.alpha = 0.5;

    box.checkCollisions = true; // VERMELHA


     var box2 = BABYLON.MeshBuilder.CreateBox("box", {size: 10}, cena_Mundo);
     box2.position = new BABYLON.Vector3(18, 26, 8);
     
     box2.material = new BABYLON.StandardMaterial("materialGround", cena_Mundo);
     //  box2.material.emissiveColor = new BABYLON.Color3.Green();
     box2.material.diffuseColor = new BABYLON.Color3.Green();
     box2.material.alpha = 0.5;

     box2.checkCollisions = true; // VERDE


     cena_Mundo.registerBeforeRender(function (){
        if (cena_Mundo.isReady()) {

            // # Optimizar para funcionar com todos os elementos  em um loop
            evento_Colidir(character, box, explode_);
            // evento_Colidir(character, box2, explode_);

            evento_Colidir(character, box2, queima_);
        }
     });

    // Adiciona brilho a tudo
    // var gl = new BABYLON.GlowLayer("gl", cena_Mundo);
    // var pipeline = new BABYLON.DefaultRenderingPipeline(
    //     "pipeline", true, cena_Mundo, [camera]
    // );
    // pipeline.samples = 4;
    // var ssao = new BABYLON.SSAORenderingPipeline('ssaopipeline', cena_Mundo, { ssaoRatio: 0.75, combineRatio: 1.0 }, [camera]);
    // var postProcess = new BABYLON.PostProcess("anamorphic effects", "anamorphicEffects", [], null, 1, camera);

    
    // ground_1.material = new BABYLON.GridMaterial("groundMat");


    var pause = false;

    // # Usar checkboxes e radios
    cena_Mundo.onKeyboardObservable.add((kbInfo) => {
        switch (kbInfo.type) {
            case BABYLON.KeyboardEventTypes.KEYDOWN:
                switch (kbInfo.event.key) {
                    case "1": // 1ª visão
                        camera.lowerRadiusLimit = 5;
                        camera.upperRadiusLimit = 100;
                        camera.radius = 20;
                        break

                    case "2": // 2ª visão
                        camera.lowerRadiusLimit = 35;
                        camera.upperRadiusLimit = 200;
                        camera.radius = 20;
                        break
                    
                    case "3": // 3ª visão
                        camera.lowerRadiusLimit = 60;
                        camera.upperRadiusLimit = 600;
                        camera.radius = 30;
                        break

                    case "p": //Pausar/Despausar o jogo
                        if (!pause) {
                            pause = true;

                            // Rotaciona a camera orbitando o herói
                            cena_Mundo.activeCamera.useAutoRotationBehavior = true;
                            
                            // Desabilitar controle?

                            // Exibir mensagem com botão [CONTINUAR]
                            
                        }
                        else {
                            // Ao clicar em [CONTINUAR] é feito reconhecimento facial
                            //  e habilita o controle do jogo 

                            // Para a rotação da camera
                            cena_Mundo.activeCamera.useAutoRotationBehavior = false;

                            // Resetar posição da camera
                            camera.lowerRadiusLimit = 35;
                            camera.upperRadiusLimit = 200;
                            camera.radius = 20;

                            
                            // camera.setPosition(new BABYLON.Vector3((BLOCK_SIZE * Maze_size_X / 2 * -1) - 40, BLOCK_SIZE * 6, (BLOCK_SIZE * Maze_size_Z / 2 * -1) + 12));
                            camera.setPosition(new BABYLON.Vector3(0, 1.35, -5));
                            
                            // updateCamera();
                            // Atualiza a posição da câmera para ficar sempre atrás do player
                            // camera.position.x = character.position.x;
                            // camera.position.z = character.position.z; // ajuste a distância da câmera do player aqui
                            // camera.position.y = character.position.y + 5; // ajuste a altura da câmera aqui

                            // Atualiza a rotação da câmera para sempre olhar para o player
                            // camera.rotation.x = 0;
                            // camera.rotation.y = character.rotation.y;
                            // camera.rotation.z = 0;

                            // Habilitar controle?
                            
                            // Tirar um print da tela com rosto do jogador e savar

                            pause = false;
                        }
                        break

                        // case "m": // Ativar/Desativar trilha sonora
                        // if (!mudo) {
                        //     //...
                        //     mudo = true;
                        // }
                        // else {
                        //     //...
                        //     mudo = false;
                        // }
                        // break
                }
        }
    });

    //# Adiciona o PORTAL NORTE no LABIRINTO!!
     
    // });

    //# Adiciona o PORTAL SUL no LABIRINTO!!
     
    // });

    //# Adiciona o PORTAL SUDESTE no LABIRINTO!!
     
    // });

    //# Adiciona o PORTAL CENTRO-OESTE no LABIRINTO!!
     
    // });

    // Adiciona o GIGANTE
    // BABYLON.SceneLoader.ImportMesh("", Assets.meshes.Yeti.rootUrl, Assets.meshes.Yeti.filename, cena_Mundo, function (mesh_Gigante) {
    //     mesh_Gigante[0].scaling = new BABYLON.Vector3(0.1, 0.1, 0.1);
    //     mesh_Gigante[0].position = new BABYLON.Vector3(0, 0, 20);

    //     //mesh_Gigante.checkCollisions = true;
    // });

    // Adiciona o Bordo Japonês
    BABYLON.SceneLoader.ImportMesh("", "", bordo, cena_Mundo, function (mesh_Bordo) {
        mesh_Bordo[0].scaling = new BABYLON.Vector3(30, 30, 30);
        mesh_Bordo[0].position = new BABYLON.Vector3(25, 17, 0);

        mesh_Bordo[0].checkCollisions = true;

    });

    // Adiciona o Cacto simples
    BABYLON.SceneLoader.ImportMesh("", "", cacto_1, cena_Mundo, function (mesh_Cacto_2) {
        mesh_Cacto_2[0].scaling = new BABYLON.Vector3(20, 20, 20);
        mesh_Cacto_2[0].position = new BABYLON.Vector3(15, 24, -3);
    });

    // Adiciona o Cacto realista
    BABYLON.SceneLoader.ImportMesh("", "", cacto_2, cena_Mundo, function (mesh_Cacto_1) {
        mesh_Cacto_1[0].scaling = new BABYLON.Vector3(30, 30, 30);
        mesh_Cacto_1[0].position = new BABYLON.Vector3(10, 29, -2);
    });

    // // Adiciona as Folhas caindo
    // BABYLON.SceneLoader.ImportMesh("", "", folhas_caindo, cena_Mundo, function (mesh_Folhas) {
    //     mesh_Folhas[0].scaling = new BABYLON.Vector3(20, 20, 20);

    //# Adiciona o PORTAL NORDESTE no LABIRINTO!!
     
    //     mesh_Folhas[0].position = new BABYLON.Vector3(25, 0, 0);

    // });
    
    // Adiciona a Pilha de folhas
    BABYLON.SceneLoader.ImportMesh("", "", pilha_folhas, cena_Mundo, function (mesh_Pilha_Folhas) {
        mesh_Pilha_Folhas[0].scaling = new BABYLON.Vector3(50, 50, 50);
        mesh_Pilha_Folhas[0].position = new BABYLON.Vector3(23, 23, 0);
    });

    // Adiciona a Macieira
    BABYLON.SceneLoader.ImportMesh("", "", macieira, cena_Mundo, function (mesh_Macieira) {
        mesh_Macieira[0].scaling = new BABYLON.Vector3(8, 8, 8);
        mesh_Macieira[0].position = new BABYLON.Vector3(20, 26, -10);

        mesh_Macieira.checkCollisions = true;
    });

    // // Adiciona a Pinheiro Nevado
    // BABYLON.SceneLoader.ImportMesh("", "", pinheiro_nevado, cena_Mundo, function (mesh_Pinheiro) {
    //     mesh_Pinheiro[0].scaling = new BABYLON.Vector3(5, 5, 5);
    //     mesh_Pinheiro[0].position = new BABYLON.Vector3(30, 19, -15);

    //     mesh_Pinheiro.checkCollisions = true;
    // });


     // Adiciona o NPC que acompanhará o herói
    //  BABYLON.SceneLoader.ImportMesh("", "./assets/personagens/npc/", "xx.glb", cena_Mundo, function (mesh_NPC, particleSystems, skeletons_NPC) {
    //     mesh_NPC[0].scaling = new BABYLON.Vector3(0.3, 0.3, 0.3);
    //     mesh_NPC[0].position = new BABYLON.Vector3(0, 19, 15);
    //     // mesh_NPC[0].position = main.position;

    //     // mesh_NPC[0].collisionsEnabled;
    //     // mesh_NPC[0].checkCollisions = true;
    
    //     // mesh_NPC[0].parent = main;

    //     main.moveWithCollisions(m.add(meshmesh_NPC_Bee[0]));



      // Adiciona elemento o item informativo
    //   BABYLON.SceneLoader.ImportMesh("", "./ambiente/", "parabens.glb", cena_Mundo, function(mesh_elemento){
    //     // mesh_elemento[0].scaling = new BABYLON.Vector3(0.05, 0.05, 0.05);
    //     mesh_elemento[0].position = new BABYLON.Vector3(0, 19, -18);
    //  });  


    // Adiciona a MÃO
    //BABYLON.SceneLoader.ImportMesh("", "./scenes/", "hand.babylon", cena_Mundo, function (newMeshes, particleSystems, skeletons) {

    /* Sistemas de particulas utilizados como checkinpoint em 3 situações:
    1. Para salvar o progresso;
    2. Como gatilhos para disparar as cutscenes (videos que desenvolvem o enredo e geralmente
    são mostradas na conclusão de um nível, quando o personagem completa a fase e entre
    cada pequena missão, preenchendo as lacunas da história);
    3. Para executar os vídeos com instruções de como realizar a respectiva tarefa.*/
    
    // Deve haver um par de portal para cada dimenssão
    // Portal da dimensão da 1ª tarefa
    var portal_Azul = geraPortal("assets/textures/portal/blue_Portal1.png", new BABYLON.Vector3(0, 20, -10));
    var portal_Vermelho = geraPortal("assets/textures/portal/red_Portal1.png", new BABYLON.Vector3(0, 20, 0));

    // Portal da dimensão da 2ª tarefa
    var portal_Azul = geraPortal("assets/textures/portal/blue_Portal1.png", new BABYLON.Vector3(2, 20, -10));
    var portal_Vermelho = geraPortal("assets/textures/portal/red_Portal1.png", new BABYLON.Vector3(-2, 20, 0));

    // Portal da dimensão da 3ª tarefa
    var portal_Azul = geraPortal("assets/textures/portal/blue_Portal1.png", new BABYLON.Vector3(2, 20, -10));
    var portal_Vermelho = geraPortal("assets/textures/portal/red_Portal1.png", new BABYLON.Vector3(-2, 20, 0));   

     // HUD (Heads-Up Display)>>>------------------------------------------------------------------------->
    
    var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("GUI");
    //  gui.idealWidth = 1000; // # Quanto maior o valor, menor ficam os textos

    // BOTÃO: Câmera do jogador
    // var Button_Camera = BABYLON.GUI.Button.CreateSimpleButton("butCam", "Camera");
    // Button_Camera.paddingTop = "10px";
    // Button_Camera.width = "100px";
    // Button_Camera.height = "50px";
    // Button_Camera.color = "white";
    // Button_Camera.background = "black";

    // var camera_Off = true;
    // Button_Camera.onPointerDownObservable.add(() => {
    //     if (Button_Camera) {
    //         // if (camera_Off) {
    //             cameraPlayer.start();
    //             console.log("ligou CÂMERA");
    //             // camera_Off = false;
    //         // }
    //         // if (!camera_Off) {
    //         //     cameraPlayer.stop();
    //         //     console.log("Desligou CÂMERA");
    //         //     camera_Off = true;
    //         // }
    //         Button_Camera = 0;
    //     }
    // });
    // gui.addControl(Button_Camera);

    // 2. Pontuação e tentativas
    // Cria um novo container para o HUD
    //E. Barra superior
    var barraSuperior = new BABYLON.GUI.StackPanel();
    barraSuperior.isVertical = false;
    barraSuperior.background = "black"; 
    barraSuperior.alpha = 0.5;
    // panel.background = "transparent";
    barraSuperior.horizontalAlignment = 1;
    barraSuperior.verticalAlignment = 0;
    barraSuperior.width = "100%";
    barraSuperior.height = "60px";

    // Botão que habilita a interação do usuário com a interface gráfica
    // var gui_ativado = false;
    activateBtn = BABYLON.GUI.Button.CreateImageOnlyButton("ativar", "assets/gui/activateButton.png");
    activateBtn.width = "130px";
    activateBtn.height = "55px";
    activateBtn.thickness = 0;
    // activateBtn.VerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
    // activateBtn.HorizontalAlignment = "right";
    // activateBtn.HorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_BOTTOM;

    activateBtn.onPointerClickObservable.add(function() {
        if(barraSuperior.isVisible){
            barraSuperior.isVisible = false;
        }
        else{
            barraSuperior.isVisible = true;
        }
    });

    // F. Barra inferior
    var barraInferior = new BABYLON.GUI.StackPanel();
    barraInferior.isVertical = true;
    barraInferior.background = "black"; 
    barraInferior.alpha = 0.5;
    barraInferior.horizontalAlignment = 0;
    barraInferior.verticalAlignment = 1;
    barraInferior.width = "100%";
    barraInferior.height = "60px";

    // Cria um componente de texto para exibir a pontuação
    var scoreText = new BABYLON.GUI.TextBlock();
    scoreText.text = "Pontuação: 0";
    scoreText.height = "30px";
    scoreText.color = "white";

    barraSuperior.addControl(scoreText);

    // Cria um componente de texto para exibir o tempo restante
    var timeText = new BABYLON.GUI.TextBlock();
    timeText.text = "Tempo restante: 60";
    timeText.height = "30px";
    timeText.color = "white";
    timeText.textHorizontalAlignment = "right";

    barraSuperior.addControl(timeText);

   
    // Cria um componente de texto para exibir o estágio atual
    var estagioText = new BABYLON.GUI.TextBlock();
    estagioText.text = "Estágio: " + counter;
    estagioText.height = "30px";
    estagioText.color = "white";
    // barraSuperior.textHorizontalAlignment = "left";
    estagioText.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
    barraSuperior.addControl(estagioText);
    gui.addControl(barraSuperior);
   
    // Instruções e atalhos
    var atalhos = new BABYLON.GUI.TextBlock();
    atalhos.text =  "Para controlar o personagem, use WASD do teclado ou a tela.\n" +
                    "- P: pausar/continuar o jogo\n" +
                    "- 1, 2, 3: alternar os modos de visão da camera\n" +
                    "- M: ativar/Desativar trilha sonora\n" +
                    "- F: ativar habilidade especial 1 (fogo)";
                    "- C: ativar habilidade especial 2 (chuva)";
                    "- S: ativar habilidade especial 3 (fumaça)";
                    "- E: ativar habilidade especial 4 (explosão)";
    atalhos.color = "white";
    atalhos.fontSize = 10;
    atalhos.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
    // atalhos.textHorizontalAlignment = "left";
    // atalhos.textVerticalAlignment = "bottom"; // não funciona!!
    atalhos.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;

    barraInferior.addControl(atalhos);
    gui.addControl(atalhos);

    barraInferior.addControl(activateBtn);
    gui.addControl(barraInferior);


    // Atmosfera 1
    var skySize = 512.0;
    // var skybox = BABYLON.MeshBuilder.CreateBox("SkyBox", {size:512.0}, cena_Mundo);
    // var skyboxMaterial = new BABYLON.StandardMaterial("skyboxMaterial", cena_Mundo);
    // skyboxMaterial.backFaceCulling = false;
    // //  skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets/skybox/9.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/bosque1.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/bosque2.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/bancoBosque.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/ceuRosa.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/ceuTropical.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/ceuCarregado.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/ceuAzul.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/estacionamento.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/escadarias.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/predioNevoeiro.hdr", cena_Mundo, 512);     
    // // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/montanhasNeve.hdr", cena_Mundo, 512);     
    // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets_ignorados/skybox/montanhasRocha.hdr", cena_Mundo, 512);     
    // skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    // skybox.material = skyboxMaterial;
    // // skybox.position = new BABYLON.Vector3(x, y, z);


    // Atmosfera 2
    var skybox = BABYLON.Mesh.CreateBox("Skybox", skySize, cena_Mundo, undefined, BABYLON.Mesh.BACKSIDE);
    var skyboxMaterial = new BABYLON.BackgroundMaterial("skyboxMaterial", cena_Mundo);
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture(atmosfera, cena_Mundo);
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skybox.material = skyboxMaterial;


    // IDENTIFICADORES DE ELEMENTOS NO AMBIENTE ------------------------------------------
    var identificadores = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
    // identificadores.idealWidth = 1600;

    var etiqueta_1 = criaEtiqueta(identificadores, box, "Parede");
    var etiqueta_2 = criaEtiqueta(identificadores, box2, "Portal");  
    var etiqueta_3 = criaEtiqueta(identificadores, character, "Leinylson");  
    // var etiqueta_4 = criaEtiqueta(identificadores, mesh_Bee, "Me siga!");  

    // identificadores.addControl(etiqueta_3, etiqueta_2);

//------------------------------- Animação dos elementos- --------------------------------

// Girar o cenário rapidamente e dá um zoomIN na tarefa 
    // zoomIn(camera,ground);
    // zoomIn(camera, character);
    
//# Passear pelo cenário rapidamente e dá um zoomOUT no ambiente 
    // zoomOut(camera,ground);
    // zoomOut(camera, character);

    //# Animação de translação 
    // var frameRate = 10;


    //# Animação de rotação
    var alpha = 0;
    // asteroide.position.x = 1050;
    // asteroide.position.z = 150;

    cena_Mundo.registerBeforeRender(function (){
        
        // Rotação
        // box.rotation.x += 0.001;
        // box.rotation.y += 0.001;
        // box.rotation.z += 0.001;

        // zoomIn(camera,box); // Fica seguindo a caixa....
        // zoomIn(camera,bola); // Trava na bola

        // box.position = new BABYLON.Vector3(Math.cos(alpha)*30, 10, Math.sin(alpha)*30);
        // alpha += 0.01;

        // mesh_planeta_Lava.position = new BABYLON.Vector3(Math.cos(alpha)*30, 10, Math.sin(alpha)*30);

        // Localização
        // asteroide.position.x = 10*Math.cos(alpha);
        // asteroide.position.y = 1.0;
        // asteroide.position.z = 10*Math.sin(alpha);

        // Tamanho
        // asteroide.scaling.x = 10*Math.cos(alpha);
        // asteroide.scaling.y = 1.0;
        // asteroide.scaling.z = 10*Math.sin(alpha);

        alpha += 0.01 * cena_Mundo.getAnimationRatio();

    });

	// RETORNA A CENA AQUI!!!!!!!!!!!!!!1

	


// Create Materials
	    var goalMaterial = new BABYLON.StandardMaterial("goal", cena_Mundo);
	    var goaltexture = new BABYLON.Texture("./textures/Goal_02.png", cena_Mundo);
		goalMaterial.diffuseTexture = goaltexture;
	    var cubeMaterial = new BABYLON.StandardMaterial("cube", cena_Mundo);
	    var cubetexture = new BABYLON.Texture("./textures/block_texture.png", cena_Mundo);
		cubeMaterial.diffuseTexture = cubetexture;
	    var LIFTcubeMaterial = new BABYLON.StandardMaterial("LIFTcube", cena_Mundo);
	    var LIFTcubetexture = new BABYLON.Texture("./textures/lift_texture_01.png", cena_Mundo);
		LIFTcubeMaterial.diffuseTexture = LIFTcubetexture;
	    var bulb = BABYLON.Mesh.CreateSphere('bulb', 10, 1.0, cena_Mundo);
	    var columns = 6;
	    var rows = 1;
	    var faceUV = new Array(6);
	    for (var i = 0; i < 6; i++) {
	        faceUV[i] = new BABYLON.Vector4(i / columns, 0, (i + 1) / columns, 1 / rows);
	    }
	    var options = {
			width: BLOCK_SIZE,
			height: BLOCK_SIZE,
			depth: BLOCK_SIZE,
	        faceUV: faceUV
	    };
	    var options_L = {
			width: (BLOCK_SIZE - 0.2),
			height: BLOCK_SIZE,
			depth: (BLOCK_SIZE - 0.2),
	        faceUV: faceUV
	    };
	    var options_G = {
			width: BLOCK_SIZE,
			height: 0.2,
			depth: BLOCK_SIZE,
	        faceUV: faceUV
	    };

// Cria o labirinto
for (var vrt = 0; vrt < Maze_size_Y + 4; vrt++) {
    for (var row = 0; row < Maze_size_X + 4; row++) {
        for (var col = 0; col < Maze_size_Z + 4; col++) {

        // Parede do labirinto
        if(Temp_Room[vrt][row][col] == "W") {
            var cube = BABYLON.MeshBuilder.CreateBox('Cube', options, cena_Mundo);
            cube.material = cubeMaterial;
            cube.position = new BABYLON.Vector3(BLOCK_SIZE / 2 + (row - (Maze_size_X + 4) / 2) * BLOCK_SIZE, BLOCK_SIZE * (vrt + 1 / 2), BLOCK_SIZE / 2 + (col - (Maze_size_Z + 4) / 2) * BLOCK_SIZE);
            light1.excludedMeshes.push(cube);
            shadowGenerator.addShadowCaster(cube);
            shadowGenerator.getShadowMap().renderList.push(cube);
            cube.receiveShadows = true;
        }

        // Elevador
        if(Temp_Room[vrt][row][col] == "L") {
            LIFTcube[LIFT_count] = BABYLON.MeshBuilder.CreateBox('LIFTCube', options_L, cena_Mundo);
            LIFTcube[LIFT_count].material = LIFTcubeMaterial;
            LIFTcube[LIFT_count].position = new BABYLON.Vector3(BLOCK_SIZE / 2 + (row - (Maze_size_X + 4) / 2) * BLOCK_SIZE, (BLOCK_SIZE * (vrt - 1 / 2) + 0.1), BLOCK_SIZE / 2 + (col - (Maze_size_Z + 4) / 2) * BLOCK_SIZE);
            LIFT_X[LIFT_count] = row;
            LIFT_Y[LIFT_count] = vrt;
            LIFT_Z[LIFT_count] = col;
            LIFT_YY[LIFT_count] = BLOCK_SIZE * (vrt - 1 / 2);
            Offset_LIFTY[LIFT_count] = 0;
            light1.excludedMeshes.push(LIFTcube[LIFT_count]);
                LIFTcube[LIFT_count].receiveShadows = true;
            LIFT_count = LIFT_count + 1;
        }

        // Objetivo da fase
        if(Temp_Room[vrt][row][col] == "G") {
            Goal_x = BLOCK_SIZE / 2 + (row - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
            Goal_y = BLOCK_SIZE * vrt;
            Goal_z = BLOCK_SIZE / 2 + (col - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
            var goalCube = BABYLON.MeshBuilder.CreateBox('goalCube', options_G, cena_Mundo);
            goalCube.material = goalMaterial;
            goalCube.position = new BABYLON.Vector3(Goal_x, Goal_y + 0.1, Goal_z);
            light1.excludedMeshes.push(goalCube);
            goalCube.receiveShadows = true;
            BABYLON.SceneLoader.ImportMesh("", "", gltf_data_03, cena_Mundo, function (newMeshes2) {
                var lamp = newMeshes2[0];
                lamp.position = new BABYLON.Vector3(Goal_x + 3, Goal_y, Goal_z + 3);
                lamp.scaling = new BABYLON.Vector3(1, 1, 1);
                var materialSphere = new BABYLON.StandardMaterial("sphere0", cena_Mundo);
                materialSphere.emissiveColor = new BABYLON.Color3(1.0, 0.84, 0.0);
                bulb.position = new BABYLON.Vector3(Goal_x + 3, Goal_y + 17.5, Goal_z + 3);
                bulb.material = materialSphere;
                shadowGenerator.addShadowCaster(lamp);
                shadowGenerator.getShadowMap().renderList.push(lamp);
            });
        }

        // Caixa
        if(Temp_Room[vrt][row][col] == "B") {
            var BOX_mat = new BABYLON.StandardMaterial("box_mat", cena_Mundo);
            var BOX_texture = new BABYLON.Texture("./textures/Box_07.png", cena_Mundo);
                BOX_mat.diffuseTexture = BOX_texture;
            BOX_X[BOX_count] = row;
            BOX_Y[BOX_count] = vrt;
            BOX_Z[BOX_count] = col;
            BOX[BOX_count] = BABYLON.Mesh.CreateBox("box", BLOCK_SIZE, cena_Mundo);
            BOX[BOX_count].material = BOX_mat;
            BOX[BOX_count].position = new BABYLON.Vector3(BLOCK_SIZE / 2 + (row - (Maze_size_X + 4) / 2) * BLOCK_SIZE, BLOCK_SIZE * (vrt + 1 / 2), BLOCK_SIZE / 2 + (col - (Maze_size_Z + 4) / 2) * BLOCK_SIZE);
            BOX[BOX_count].receiveShadows = true;
            Offset_BoxY[BOX_count] = 0;
            BOX_flag[BOX_count] = 0;
            light1.excludedMeshes.push(BOX[BOX_count]);
            shadowGenerator.addShadowCaster(BOX[BOX_count]);
            shadowGenerator.getShadowMap().renderList.push(BOX[BOX_count]);
            BOX[BOX_count].receiveShadows = true;
            BOX_count = BOX_count + 1;
        }

        // Inimigo # No caso não será inimigo, será um NPC
        if(Temp_Room[vrt][row][col] == "E") {
            Enemy_X[ ENEMY_count ] = BLOCK_SIZE / 2 + (row - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
            Enemy_Y[ ENEMY_count ] = BLOCK_SIZE * vrt;
            Enemy_Z[ ENEMY_count ] = BLOCK_SIZE / 2 + (col - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
            enemyX[ ENEMY_count ] = 0;
            enemyY[ ENEMY_count ] = 0;
            enemyZ[ ENEMY_count ] = 0;
            Temp_Room[vrt][row][col] = "F";
            ENEMY_count = ENEMY_count + 1;
        }

        // Player
        if(Temp_Room[vrt][row][col] == "P") {
            x = BLOCK_SIZE / 2 + (row - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
            y = BLOCK_SIZE * vrt;
            z = BLOCK_SIZE / 2 + (col - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
            Temp_Room[vrt][row][col] = "F";
            // var obj = BABYLON.MeshBuilder.CreateSphere("objORG", {diameter: 5.1}, cena_Mundo);
            //     obj.position = new BABYLON.Vector3(x, y, z);
            // camera.target = obj;
            camera.target = character;

            cena_Mundo.registerBeforeRender(function() {

                // Walking inside the ground // Caminhando dentro do chão
                if((moveX == -1) && (character.position.x <= (BLOCK_SIZE * (Maze_size_X + 2) / -2) + 2)) {
                    character.position.x = (BLOCK_SIZE * (Maze_size_X + 2) / -2) + 2;
                    moveX = 0;
                }
                if((moveX == 1) && (character.position.x >= (BLOCK_SIZE * (Maze_size_X + 2) / 2) - 2)) {
                    character.position.x = (BLOCK_SIZE * (Maze_size_X + 2) / 2) - 2;
                    moveX = 0;
                }
                if((moveZ == -1) && (character.position.z <= (BLOCK_SIZE * (Maze_size_Z + 2) / -2) + 2)) {
                    character.position.z = (BLOCK_SIZE * (Maze_size_Z + 2) / -2) + 2;
                    moveZ = 0;
                }
                if((moveZ == 1) && (character.position.z >= (BLOCK_SIZE * (Maze_size_Z + 2) / 2) - 2)) {
                    character.position.z = (BLOCK_SIZE * (Maze_size_Z + 2) / 2) - 2;
                    moveZ = 0;
                }

                if(character.position.x <= (Maze_size_X / 2 + 0.5) * BLOCK_SIZE * -1) {
                    character.position.x = (Maze_size_X / 2 + 0.5) * BLOCK_SIZE * -1;
                }
                if(character.position.x >= (Maze_size_X / 2 + 0.5) * BLOCK_SIZE) {
                    character.position.x = (Maze_size_X / 2 + 0.5) * BLOCK_SIZE;
                }
                if(character.position.z <= (Maze_size_Z / 2 + 0.5) * BLOCK_SIZE * -1) {
                    character.position.z = (Maze_size_Z / 2 + 0.5) * BLOCK_SIZE * -1;
                }
                if(character.position.z >= (Maze_size_Z / 2 + 0.5) * BLOCK_SIZE) {
                    character.position.z = (Maze_size_Z / 2 + 0.5) * BLOCK_SIZE;
                }
                x = character.position.x;
                y = character.position.y;
                z = character.position.z;


                pos_row_00 = Math.round(((x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
                pos_row_01 = Math.round((((x + limit) - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
                pos_row_02 = Math.round((((x - limit) - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
                pos_col_00 = Math.round(((z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
                pos_col_01 = Math.round((((z + limit) - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
                pos_col_02 = Math.round((((z - limit) - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
                pos_vrt_00 = Math.round((y - BLOCK_SIZE / 2) / BLOCK_SIZE);
                pos_vrt_01 = Math.round((y - BLOCK_SIZE / 2) / BLOCK_SIZE - 1);
                pos_vrt_02 = Math.round((y - BLOCK_SIZE / 2) / BLOCK_SIZE + 1);

    // Set a Change Flag for the Player's Animation
                if((moveX == 1)  && ((Temp_Room[pos_vrt_00][pos_row_01][pos_col_00] == "B") || (Temp_Room[pos_vrt_00][pos_row_01 + 1][pos_col_00] == "B"))) {
                    Change_flag = 1;
                }
                else if((moveX == -1) && ((Temp_Room[pos_vrt_00][pos_row_02][pos_col_00] == "B") || (Temp_Room[pos_vrt_00][pos_row_02 - 1][pos_col_00] == "B"))) {
                    Change_flag = 1;
                }
                else if((moveZ == 1)  && ((Temp_Room[pos_vrt_00][pos_row_00][pos_col_01] == "B") || (Temp_Room[pos_vrt_00][pos_row_00][pos_col_01 + 1] == "B"))) {
                    Change_flag = 1;
                }
                else if((moveZ == -1) && ((Temp_Room[pos_vrt_00][pos_row_00][pos_col_02] == "B") || (Temp_Room[pos_vrt_00][pos_row_00][pos_col_02 - 1] == "B"))) {
                    Change_flag = 1;
                }
                else {
                    Change_flag = 0;
                }

    // Stop at the wall
                if((moveX == 1)  && (Temp_Room[pos_vrt_00][pos_row_01][pos_col_00] == "W")) {
                    character.position.x = BLOCK_SIZE / 2 + (pos_row_00 - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    moveX = 0;
                }
                if((moveX == -1) && (Temp_Room[pos_vrt_00][pos_row_02][pos_col_00] == "W")) {
                    character.position.x = BLOCK_SIZE / 2 + (pos_row_00 - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    moveX = 0;
                }
                if((moveZ == 1)  && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_01] == "W")) {
                    character.position.z = BLOCK_SIZE / 2 + (pos_col_00 - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    moveZ = 0;
                }
                if((moveZ == -1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_02] == "W")) {
                    character.position.z = BLOCK_SIZE / 2 + (pos_col_00 - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    moveZ = 0;
                }

    // Do not move in case of three-tiered box
                if((moveX == 1) && (Temp_Room[pos_vrt_00][pos_row_01][pos_col_00] == "B") && (Temp_Room[pos_vrt_02][pos_row_01][pos_col_00] == "B") && (Temp_Room[pos_vrt_02 + 1][pos_row_01][pos_col_00] == "B")) {
                    character.position.x = BLOCK_SIZE / 2 + (pos_row_00 - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    moveX = 0;
                }
                if((moveX == -1) && (Temp_Room[pos_vrt_00][pos_row_02][pos_col_00] == "B") && (Temp_Room[pos_vrt_02][pos_row_02][pos_col_00] == "B") && (Temp_Room[pos_vrt_02 + 1][pos_row_02][pos_col_00] == "B")) {
                    character.position.x = BLOCK_SIZE / 2 + (pos_row_00 - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    moveX = 0;
                }
                if((moveZ == 1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_01] == "B") && (Temp_Room[pos_vrt_02][pos_row_00][pos_col_01] == "B") && (Temp_Room[pos_vrt_02 + 1][pos_row_00][pos_col_01] == "B")) {
                    character.position.z = BLOCK_SIZE / 2 + (pos_col_00 - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    moveZ = 0;
                }
                if((moveZ == -1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_02] == "B") && (Temp_Room[pos_vrt_02][pos_row_00][pos_col_02] == "B") && (Temp_Room[pos_vrt_02 + 1][pos_row_00][pos_col_02] == "B")) {
                    character.position.z = BLOCK_SIZE / 2 + (pos_col_00 - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    moveZ = 0;
                }

    // Stop in case of not free on the LIFT
                if((moveX == 1) && (Temp_Room[pos_vrt_00][pos_row_01][pos_col_00] == "L") && (Temp_Room[pos_vrt_00 + 1][pos_row_01][pos_col_00] != "F")) {
                    character.position.x = BLOCK_SIZE / 2 + (pos_row_00 - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    moveX = 0;
                }
                if((moveX == -1) && (Temp_Room[pos_vrt_00][pos_row_02][pos_col_00] == "L") && (Temp_Room[pos_vrt_00 + 1][pos_row_02][pos_col_00] != "F")) {
                    character.position.x = BLOCK_SIZE / 2 + (pos_row_00 - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    moveX = 0;
                }
                if((moveZ == 1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_01] == "L") && (Temp_Room[pos_vrt_00 + 1][pos_row_00][pos_col_01] != "F")) {
                    character.position.z = BLOCK_SIZE / 2 + (pos_col_00 - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    moveZ = 0;
                }
                if((moveZ == -1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_02] == "L") && (Temp_Room[pos_vrt_00 + 1][pos_row_00][pos_col_02] != "F")) {
                    character.position.z = BLOCK_SIZE / 2 + (pos_col_00 - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    moveZ = 0;
                }
                if((moveX == 1) && (Temp_Room[pos_vrt_00][pos_row_01][pos_col_00] == "B") && (Temp_Room[pos_vrt_00][pos_row_01 + 1][pos_col_00] == "L") && (Temp_Room[pos_vrt_02][pos_row_01 + 1][pos_col_00] != "F")) {
                    character.position.x = BLOCK_SIZE / 2 + (pos_row_00 - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    moveX = 0;
                }
                if((moveX == -1) && (Temp_Room[pos_vrt_00][pos_row_02][pos_col_00] == "B") && (Temp_Room[pos_vrt_00][pos_row_02 - 1][pos_col_00] == "L") && (Temp_Room[pos_vrt_02][pos_row_02 - 1][pos_col_00] != "F")) {
                    character.position.x = BLOCK_SIZE / 2 + (pos_row_00 - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    moveX = 0;
                }
                if((moveZ == 1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_01] == "B") && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_01 + 1] == "L") && (Temp_Room[pos_vrt_02][pos_row_00][pos_col_01 + 1] != "F")) {
                    character.position.z = BLOCK_SIZE / 2 + (pos_col_00 - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    moveZ = 0;
                }
                if((moveZ == -1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_02] == "B") && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_02 - 1] == "L") && (Temp_Room[pos_vrt_02][pos_row_00][pos_col_02 - 1] != "F")) {
                    character.position.z = BLOCK_SIZE / 2 + (pos_col_00 - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    moveZ = 0;
                }

    // Stop the BOX at Edge
                if((moveX == 1) && (Temp_Room[pos_vrt_00][pos_row_01][pos_col_00] == "B") && (pos_row_01 >= Maze_size_X + 2)) {
                    moveX = 0;
                }
                if((moveX == -1) && (Temp_Room[pos_vrt_00][pos_row_02][pos_col_00] == "B") && (pos_row_02 < 2)) {
                    moveX = 0;
                }
                if((moveZ == 1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_01] == "B") && (pos_col_01 >= Maze_size_Z + 2)) {
                    moveZ = 0;
                }
                if((moveZ == -1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_02] == "B") && (pos_col_02 < 2)) {
                    moveZ = 0;
                }

    // Move the Box
                if((Move_flag == 0) && (moveX == 1) && (Temp_Room[pos_vrt_00][pos_row_01][pos_col_00] == "B")) {
                    if((Temp_Room[pos_vrt_00][pos_row_01 + 1][pos_col_00] == "F") || (Temp_Room[pos_vrt_00][pos_row_01 + 1][pos_col_00] == "L")) {
                        Move_flag = 1;
                        for(var i = 0; i < BOX.length; i++) {
                            BOX_flag[ i ] = 0;
                            Offset_BoxY[ i ] = 0;
                            if((Math.round(((BOX[ i ].position.x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2) == pos_row_01) && (Math.round(((BOX[ i ].position.z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2) == pos_col_00)) {
                            if((Temp_count < 0) && (Math.round((BOX[ i ].position.y - BLOCK_SIZE / 2) / BLOCK_SIZE)) == pos_vrt_00) {
                                Temp_count = i;
                            }
                            if((Temp_Room[pos_vrt_02][pos_row_01][pos_col_00] == "B") && (Math.round(BOX[ i ].position.y - BLOCK_SIZE / 2) / BLOCK_SIZE) == pos_vrt_02) {
                                Temp_count_02 = i;
                            }
                            }
                        }
                    } else {
                        moveX = 0;
                        Move_flag = 0;
                    }
                }
                if(Move_flag == 1 && Temp_count >= 0) {
                    BOX[ Temp_count ].position.x = BOX[ Temp_count ].position.x + walk_step;
                    if(Temp_count_02 >= 0) {
                        BOX[ Temp_count_02 ].position.x = BOX[ Temp_count ].position.x;
                    }
                    BOX_move_flag = BOX_move_flag + walk_step;
                    if(BOX_move_flag >= BLOCK_SIZE) {
                    BOX_X[ Temp_count ] = BOX_X[ Temp_count ] + 1;
                    BOX[ Temp_count ].position.x = BLOCK_SIZE / 2 + (BOX_X[ Temp_count ] - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    if(Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ] - 1][BOX_Z[ Temp_count ]] == "B") {
                        Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ] - 1][BOX_Z[ Temp_count ]] = "F";
                    }
                    if(Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] == "F") {
                        Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] = "B";
                        if((BOX_Y[ Temp_count ] > 2) && (Temp_Room[BOX_Y[ Temp_count ] - 1][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] == "F")) {
                            BOX_flag[ Temp_count ] = 1;
                            Temp_DOWN = Temp_count;
                            moveX = 0;
                        }
                    }
                    if(Temp_Room[pos_vrt_00][pos_row_01 + 1][pos_col_00] == "L" || Temp_Room[pos_vrt_01][pos_row_01 + 1][pos_col_00] == "L") {
                        if(Temp_Room[pos_vrt_00][pos_row_01][pos_col_00] == "B") {
                            Temp_Room[pos_vrt_00][pos_row_01][pos_col_00] = "F";
                        }
                        Temp_BOX_n = Temp_count;
                        Temp_BOX_x = pos_row_01 + 1;
                        Temp_BOX_y = pos_vrt_00;
                        Temp_BOX_z = pos_col_00;
                    }
                    if(Temp_count_02 >= 0) {
                        BOX[ Temp_count_02 ].position.x = BOX[ Temp_count ].position.x;
                        Temp_Room[BOX_Y[ Temp_count_02 ]][BOX_X[ Temp_count ] - 1][BOX_Z[ Temp_count ]] = "F";
                        Temp_Room[BOX_Y[ Temp_count_02 ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] = "B";
                        BOX_X[ Temp_count_02 ] = BOX_X[ Temp_count ];
                        BOX_Y[ Temp_count_02 ] = BOX_Y[ Temp_count ] + 1;
                    }
                    BOX_move_flag = 0;
                    Temp_count = -1;
                    Temp_count_02 = -1;
                    Move_flag = 0;
                    }
                }

                if((Move_flag == 0) && (moveX == -1) && (Temp_Room[pos_vrt_00][pos_row_02][pos_col_00] == "B")) {
                    if((Temp_Room[pos_vrt_00][pos_row_02 - 1][pos_col_00] == "F") || (Temp_Room[pos_vrt_00][pos_row_02 - 1][pos_col_00] == "L")) {
                        Move_flag = 2;
                        for(var i = 0; i < BOX.length; i++) {
                            BOX_flag[ i ] = 0;
                            Offset_BoxY[ i ] = 0;
                            if((Math.round(((BOX[ i ].position.x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2) == pos_row_02) && (Math.round(((BOX[ i ].position.z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2) == pos_col_00)) {
                                if((Temp_count < 0) && (Math.round((BOX[ i ].position.y - BLOCK_SIZE / 2) / BLOCK_SIZE)) == pos_vrt_00) {
                                    Temp_count = i;
                                }   
                                if((Temp_Room[pos_vrt_02][pos_row_02][pos_col_00] == "B") && (Math.round(BOX[ i ].position.y - BLOCK_SIZE / 2) / BLOCK_SIZE) == pos_vrt_02) {
                                    Temp_count_02 = i;
                                }
                            }
                        }
                    } else {
                        moveX = 0;
                        Move_flag = 0;
                    }
                }
                if(Move_flag == 2 && Temp_count >= 0) {
                    BOX[ Temp_count ].position.x = BOX[ Temp_count ].position.x - walk_step;
                    if(Temp_count_02 >= 0) {
                        BOX[ Temp_count_02 ].position.x = BOX[ Temp_count ].position.x;
                    }
                    BOX_move_flag = BOX_move_flag + walk_step;
                    if(BOX_move_flag >= BLOCK_SIZE) {
                    BOX_X[ Temp_count ] = BOX_X[ Temp_count ] - 1;
                    BOX[ Temp_count ].position.x = BLOCK_SIZE / 2 + (BOX_X[ Temp_count ] - (Maze_size_X + 4) / 2) * BLOCK_SIZE;
                    if(Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ] + 1][BOX_Z[ Temp_count ]] == "B") {
                        Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ] + 1][BOX_Z[ Temp_count ]] = "F";
                    }
                    if(Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] == "F") {
                        Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] = "B";
                        if((BOX_Y[ Temp_count ] > 2) && (Temp_Room[BOX_Y[ Temp_count ] - 1][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] == "F")) {
                            BOX_flag[ Temp_count ] = 1;
                            Temp_DOWN = Temp_count;
                            moveX = 0;
                        }
                    }
                    if(Temp_Room[pos_vrt_00][pos_row_02 - 1][pos_col_00] == "L" || Temp_Room[pos_vrt_01][pos_row_02 - 1][pos_col_00] == "L") {
                        if(Temp_Room[pos_vrt_00][pos_row_02][pos_col_00] == "B") {
                            Temp_Room[pos_vrt_00][pos_row_02][pos_col_00] = "F";
                        }
                        Temp_BOX_n = Temp_count;
                        Temp_BOX_x = pos_row_02 - 1;
                        Temp_BOX_y = pos_vrt_00;
                        Temp_BOX_z = pos_col_00;
                    }
                    if(Temp_count_02 >= 0) {
                        BOX[ Temp_count_02 ].position.x = BOX[ Temp_count ].position.x;
                        Temp_Room[BOX_Y[ Temp_count_02 ]][BOX_X[ Temp_count ] + 1][BOX_Z[ Temp_count ]] = "F";
                        Temp_Room[BOX_Y[ Temp_count_02 ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] = "B";
                        BOX_X[ Temp_count_02 ] = BOX_X[ Temp_count ];
                        BOX_Y[ Temp_count_02 ] = BOX_Y[ Temp_count ] + 1;
                    }
                    BOX_move_flag = 0;
                    Temp_count = -1;
                    Temp_count_02 = -1;
                    Move_flag = 0;
                    }
                }

                if((Move_flag == 0) && (moveZ == 1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_01] == "B")) {
                    if((Temp_Room[pos_vrt_00][pos_row_00][pos_col_01 + 1] == "F") || (Temp_Room[pos_vrt_00][pos_row_00][pos_col_01 + 1] == "L")) {
                    Move_flag = 3;
                    for(var i = 0; i < BOX.length; i++) {
                        BOX_flag[ i ] = 0;
                        Offset_BoxY[ i ] = 0;
                        if((Math.floor(((BOX[ i ].position.x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2) == pos_row_00) && (Math.round(((BOX[ i ].position.z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2) == pos_col_01)) {
                            if((Temp_count < 0) && (Math.round((BOX[ i ].position.y - BLOCK_SIZE / 2) / BLOCK_SIZE)) == pos_vrt_00) {
                                Temp_count = i;
                            }
                            if((Temp_Room[pos_vrt_02][pos_row_00][pos_col_01] == "B") && (Math.round(BOX[ i ].position.y - BLOCK_SIZE / 2) / BLOCK_SIZE) == pos_vrt_02) {
                                Temp_count_02 = i;
                            }
                        }
                    }
                    } else {
                        moveZ = 0;
                        Move_flag = 0;
                    }
                }
                if(Move_flag == 3 && Temp_count >= 0) {
                    BOX[ Temp_count ].position.z = BOX[ Temp_count ].position.z + walk_step;
                    if(Temp_count_02 >= 0) {
                        BOX[ Temp_count_02 ].position.z = BOX[ Temp_count ].position.z;
                    }
                    BOX_move_flag = BOX_move_flag + walk_step;
                    if(BOX_move_flag >= BLOCK_SIZE) {
                    BOX_Z[ Temp_count ] = BOX_Z[ Temp_count ] + 1;
                    BOX[ Temp_count ].position.z = BLOCK_SIZE / 2 + (BOX_Z[ Temp_count ] - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    if(Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ] - 1] == "B") {
                        Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ] - 1] = "F";
                    }
                    if(Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] == "F") {
                        Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] = "B";
                        if((BOX_Y[ Temp_count ] > 2) && (Temp_Room[BOX_Y[ Temp_count ] - 1][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] == "F")) {
                            BOX_flag[ Temp_count ] = 1;
                            Temp_DOWN = Temp_count;
                            moveZ = 0;
                        }
                    }
                    if(Temp_Room[pos_vrt_00][pos_row_00][pos_col_01 + 1] == "L" || Temp_Room[pos_vrt_01][pos_row_00][pos_col_01 + 1] == "L") {
                        if(Temp_Room[pos_vrt_00][pos_row_00][pos_col_01] == "B") {
                            Temp_Room[pos_vrt_00][pos_row_00][pos_col_01] = "F";
                        }
                        Temp_BOX_n = Temp_count;
                        Temp_BOX_x = pos_row_00;
                        Temp_BOX_y = pos_vrt_00;
                        Temp_BOX_z = pos_col_01 + 1;
                    }
                    if(Temp_count_02 >= 0) {
                        BOX[ Temp_count_02 ].position.z = BOX[ Temp_count ].position.z;
                        Temp_Room[BOX_Y[ Temp_count_02 ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ] - 1] = "F";
                        Temp_Room[BOX_Y[ Temp_count_02 ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] = "B";
                        BOX_Y[ Temp_count_02 ] = BOX_Y[ Temp_count ] + 1;
                        BOX_Z[ Temp_count_02 ] = BOX_Z[ Temp_count ];
                    }
                    BOX_move_flag = 0;
                    Temp_count = -1;
                    Temp_count_02 = -1;
                    Move_flag = 0;
                    }
                }

                if((Move_flag == 0) && (moveZ == -1) && (Temp_Room[pos_vrt_00][pos_row_00][pos_col_02] == "B")) {
                    if((Temp_Room[pos_vrt_00][pos_row_00][pos_col_02 - 1] == "F") || (Temp_Room[pos_vrt_00][pos_row_00][pos_col_02 - 1] == "L")) {
                    Move_flag = 4;
                    for(var i = 0; i < BOX.length; i++) {
                        BOX_flag[ i ] = 0;
                        Offset_BoxY[ i ] = 0;
                        if((Math.floor(((BOX[ i ].position.x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2) == pos_row_00) && (Math.round(((BOX[ i ].position.z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2) == pos_col_02)) {
                        if((Temp_count < 0) && (Math.round((BOX[ i ].position.y - BLOCK_SIZE / 2) / BLOCK_SIZE)) == pos_vrt_00) {
                            Temp_count = i;
                        }
                        if((Temp_Room[pos_vrt_02][pos_row_00][pos_col_02] == "B") && (Math.round(BOX[ i ].position.y - BLOCK_SIZE / 2) / BLOCK_SIZE) == pos_vrt_02) {
                            Temp_count_02 = i;
                        }
                        }
                    }
                    } else {
                        moveZ = 0;
                        Move_flag = 0;
                    }
                }
                if(Move_flag == 4 && Temp_count >= 0) {
                    BOX[ Temp_count ].position.z = BOX[ Temp_count ].position.z - walk_step;
                    if(Temp_count_02 >= 0) {
                        BOX[ Temp_count_02 ].position.z = BOX[ Temp_count ].position.z;
                    }
                    BOX_move_flag = BOX_move_flag + walk_step;
                    if(BOX_move_flag >= BLOCK_SIZE) {
                    BOX_Z[ Temp_count ] = BOX_Z[ Temp_count ] - 1;
                    BOX[ Temp_count ].position.z = BLOCK_SIZE / 2 + (BOX_Z[ Temp_count ] - (Maze_size_Z + 4) / 2) * BLOCK_SIZE;
                    if(Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ] + 1] == "B") {
                        Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ] + 1] = "F";
                    }
                    if(Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] == "F") {
                        Temp_Room[BOX_Y[ Temp_count ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] = "B";
                        if((BOX_Y[ Temp_count ] > 2) && (Temp_Room[BOX_Y[ Temp_count ] - 1][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] == "F")) {
                            BOX_flag[ Temp_count ] = 1;
                            Temp_DOWN = Temp_count;
                            moveZ = 0;
                        }
                    }
                    if(Temp_Room[pos_vrt_00][pos_row_00][pos_col_02 - 1] == "L" || Temp_Room[pos_vrt_01][pos_row_00][pos_col_02 - 1] == "L") {
                        if(Temp_Room[pos_vrt_00][pos_row_00][pos_col_02] == "B") {
                            Temp_Room[pos_vrt_00][pos_row_00][pos_col_02] = "F";
                        }
                        Temp_BOX_n = Temp_count;
                        Temp_BOX_x = pos_row_00;
                        Temp_BOX_y = pos_vrt_00;
                        Temp_BOX_z = pos_col_02 - 1;
                    }
                    if(Temp_count_02 >= 0) {
                        BOX[ Temp_count_02 ].position.z = BOX[ Temp_count ].position.z;
                        Temp_Room[BOX_Y[ Temp_count_02 ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ] + 1] = "F";
                        Temp_Room[BOX_Y[ Temp_count_02 ]][BOX_X[ Temp_count ]][BOX_Z[ Temp_count ]] = "B";
                        BOX_Y[ Temp_count_02 ] = BOX_Y[ Temp_count ] + 1;
                        BOX_Z[ Temp_count_02 ] = BOX_Z[ Temp_count ];
                    }
                    BOX_move_flag = 0;
                    Temp_count = -1;
                    Temp_count_02 = -1;
                    Move_flag = 0;
                    }
            }

// Player LIFT up
            if((Temp_Room[pos_vrt_00][pos_row_00][pos_col_00] == "L") || (Temp_Room[pos_vrt_01][pos_row_00][pos_col_00] == "L")) {
                for (var LIFT_i = 0; LIFT_i < LIFT_count; LIFT_i ++) {
                    var LIFT_x = Math.round(((LIFTcube[LIFT_i].position.x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
                    var LIFT_z = Math.round(((LIFTcube[LIFT_i].position.z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
                    if((pos_row_00 == LIFT_x) && (pos_col_00 == LIFT_z)) {
                        if(LIFTcube[LIFT_i].position.y < LIFT_YY[LIFT_i] + BLOCK_SIZE) {
                            moveX = 0;
                            moveZ = 0;
                            LIFTcube[LIFT_i].position.y = LIFT_YY[LIFT_i] + Offset_LIFTY[LIFT_i];
                            character.position.y = LIFTcube[LIFT_i].position.y + BLOCK_SIZE / 2;
                            y = character.position.y;
                            Offset_LIFTY[LIFT_i] = Offset_LIFTY[LIFT_i] + up_step;
                        }
                    }
                }
            }
            else {
                for (var LIFT_i = 0; LIFT_i < LIFT_count; LIFT_i ++) {
                    Temp_LIFT_x = Math.round(((LIFTcube[LIFT_i].position.x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
                    Temp_LIFT_y = Math.round((LIFTcube[LIFT_i].position.y) / BLOCK_SIZE);
                    Temp_LIFT_z = Math.round(((LIFTcube[LIFT_i].position.z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
                    if(LIFTcube[LIFT_i].position.y > (LIFT_YY[LIFT_i] + 0.1) && Offset_LIFTY[LIFT_i] > down_step && Temp_Room[Temp_LIFT_y + 1][Temp_LIFT_x][Temp_LIFT_z] == "F") {
                        Offset_LIFTY[LIFT_i] = Offset_LIFTY[LIFT_i] - down_step;
                        LIFTcube[LIFT_i].position.y = LIFT_YY[LIFT_i] + Offset_LIFTY[LIFT_i];
                    }
                }
            }
            
// Player Drop Down
            if(pos_vrt_01 > 1 && Temp_Room[pos_vrt_01][pos_row_00][pos_col_00] == "F") {
                    DOWN_flag = 1;
                    Offset_ObY = 0;
            }
            if(DOWN_flag == 1 && Offset_ObY < BLOCK_SIZE) {
                moveX = 0;
                moveZ = 0;
                Offset_ObY = Offset_ObY + down_step;

                character.position.y = character.position.y - down_step;
                y = character.position.y;

                if(Offset_ObY >= BLOCK_SIZE) {
                    DOWN_flag = 0;

                    character.position.y = Math.round(character.position.y / BLOCK_SIZE) * BLOCK_SIZE + 0.1;
                    y = character.position.y;

                }
                if(character.position.y < BLOCK_SIZE * 2) {
                    character.position.y = BLOCK_SIZE * 2 + 0.1;
                    y = character.position.y;
                }
            }

// BOX Lift Up
            if(Temp_BOX_n >= 0) {
                moveX = 0;
                moveZ = 0;
                Temp_BOX_m = -1;
                for(var BOX_i = 0; BOX_i < BOX_count; BOX_i ++) {
                    if((BOX_X[BOX_i] == BOX_X[Temp_BOX_n]) && (BOX_Y[BOX_i] == BOX_Y[Temp_BOX_n] + 1) && (BOX_Z[BOX_i] == BOX_Z[Temp_BOX_n])) {
                        Temp_BOX_m = BOX_i;
                    }
                }
                if(Temp_LIFT_n < 0) {
                    if((Temp_Room[Temp_BOX_y][Temp_BOX_x][Temp_BOX_z] == "L") || (Temp_Room[Temp_BOX_y - 1][Temp_BOX_x][Temp_BOX_z] == "L")) {
                        for (var LIFT_i = 0; LIFT_i < LIFT_count; LIFT_i ++) {
                        var Temp_LIFT_x = Math.round(((LIFTcube[LIFT_i].position.x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
                        var Temp_LIFT_y = Math.round((LIFTcube[LIFT_i].position.y) / BLOCK_SIZE);
                        var Temp_LIFT_z = Math.round(((LIFTcube[LIFT_i].position.z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
                        if((Temp_BOX_x == Temp_LIFT_x) && (Temp_BOX_z == Temp_LIFT_z)) {
                            if(LIFTcube[LIFT_i].position.y < LIFT_YY[LIFT_i] + BLOCK_SIZE + 0.1) {
                                LIFTcube[LIFT_i].position.y = LIFT_YY[LIFT_i] + Offset_LIFTY[LIFT_i];
                                BOX[Temp_BOX_n].position.y = LIFTcube[LIFT_i].position.y + BLOCK_SIZE;
                                if(Temp_BOX_m >= 0) {
                                    BOX[Temp_BOX_m].position.x = BOX[Temp_BOX_n].position.x;
                                    BOX[Temp_BOX_m].position.y = BOX[Temp_BOX_n].position.y + BLOCK_SIZE;
                                    BOX[Temp_BOX_m].position.z = BOX[Temp_BOX_n].position.z;
                                }
                                Offset_LIFTY[LIFT_i] = Offset_LIFTY[LIFT_i] + up_step;
                                Temp_Room[Temp_LIFT_y + 1][Temp_LIFT_x][Temp_LIFT_z] = "B";
                                if(Offset_LIFTY[LIFT_i] >= BLOCK_SIZE) {
                                    BOX[Temp_BOX_n].position.x = LIFTcube[LIFT_i].position.x;
                                    BOX[Temp_BOX_n].position.y = LIFTcube[LIFT_i].position.y + BLOCK_SIZE;
                                    BOX[Temp_BOX_n].position.z = LIFTcube[LIFT_i].position.z;
                                    BOX_X[ Temp_BOX_n ] = Temp_LIFT_x;
                                    BOX_Y[ Temp_BOX_n ] = Temp_LIFT_y + 1;
                                    BOX_Z[ Temp_BOX_n ] = Temp_LIFT_z;
                                    if(Temp_BOX_m >= 0) {
                                        BOX[Temp_BOX_m].position.x = BOX[Temp_BOX_n].position.x;
                                        BOX[Temp_BOX_m].position.y = BOX[Temp_BOX_n].position.y + BLOCK_SIZE;
                                        BOX[Temp_BOX_m].position.z = BOX[Temp_BOX_n].position.z;
                                        Temp_Room[Temp_LIFT_y + 2][Temp_LIFT_x][Temp_LIFT_z] = "B";
                                        BOX_X[ Temp_BOX_m ] = BOX_X[ Temp_BOX_n ];
                                        BOX_Y[ Temp_BOX_m ] = BOX_Y[ Temp_BOX_n ] + 1;
                                        BOX_Z[ Temp_BOX_m ] = BOX_Z[ Temp_BOX_n ];
                                    }
                                    Temp_BOX_n = -1;
                                    Temp_LIFT_n = -1;
                                }
                            }
                        }
                    }
                }
            }
            }
            for(var LIFT_i = 0; LIFT_i < LIFT_count; LIFT_i ++) {
                var Temp_LIFT_x = Math.round(((LIFTcube[LIFT_i].position.x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
                var Temp_LIFT_y = Math.round((LIFTcube[LIFT_i].position.y) / BLOCK_SIZE);
                var Temp_LIFT_z = Math.round(((LIFTcube[LIFT_i].position.z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
                if(Temp_Room[Temp_LIFT_y + 1][Temp_LIFT_x][Temp_LIFT_z] == "F" && (pos_row_00 != Temp_LIFT_x && pos_vrt_00 != (Temp_LIFT_y + 1) && pos_col_00 != Temp_LIFT_z)) {
                    Offset_LIFTY[LIFT_i] = 0.1;
                    LIFTcube[LIFT_i].position.y = LIFT_YY[LIFT_i] + Offset_LIFTY[LIFT_i];
                }
                if(Temp_Room[Temp_LIFT_y + 1][Temp_LIFT_x][Temp_LIFT_z] == "B" && Offset_LIFTY[LIFT_i] < up_step) {
                    Offset_LIFTY[LIFT_i] = BLOCK_SIZE;
                    LIFTcube[LIFT_i].position.y = LIFT_YY[LIFT_i] + Offset_LIFTY[LIFT_i];
                }
            }

// BOX Drop Down
            if(Temp_DOWN >= 0) {
                moveX = 0;
                moveZ = 0;
                Temp_BOX_m = -1;
                for(var BOX_i = 0; BOX_i < BOX_count; BOX_i ++) {
                    if((BOX_X[BOX_i] == BOX_X[Temp_DOWN]) && (BOX_Y[BOX_i] == BOX_Y[Temp_DOWN] + 1) && (BOX_Z[BOX_i] == BOX_Z[Temp_DOWN])) {
                        Temp_BOX_m = BOX_i;
                    }
                }
                if(BOX_flag[Temp_DOWN] == 0 && BOX_Y[Temp_DOWN] > 2 && Temp_Room[BOX_Y[Temp_DOWN] - 1][BOX_X[Temp_DOWN]][BOX_Z[Temp_DOWN]] == "F") {
                    BOX_flag[Temp_DOWN] = 1;
                    Offset_BoxY[Temp_DOWN] = 0;
                }
                if(BOX_flag[Temp_DOWN] == 1 && Offset_BoxY[Temp_DOWN] < BLOCK_SIZE) {
                    moveX = 0;
                    moveZ = 0;
                    Offset_BoxY[Temp_DOWN] = Offset_BoxY[Temp_DOWN] + down_step;
                    BOX[Temp_DOWN].position.y = BOX[Temp_DOWN].position.y - down_step;
                    if(Temp_BOX_m >= 0) {
                        BOX[Temp_BOX_m].position.y = BOX[Temp_DOWN].position.y + BLOCK_SIZE;
                    }
                    if(Offset_BoxY[Temp_DOWN] >= BLOCK_SIZE) {
                        Temp_Room[BOX_Y[Temp_DOWN]][BOX_X[Temp_DOWN]][BOX_Z[Temp_DOWN]] = "F";
                        Temp_Room[BOX_Y[Temp_DOWN] - 1][BOX_X[Temp_DOWN]][BOX_Z[Temp_DOWN]] = "B";
                        BOX_flag[Temp_DOWN] = 0;
                        BOX[Temp_DOWN].position.y = BLOCK_SIZE * BOX_Y[Temp_DOWN] - BLOCK_SIZE / 2;
                        BOX_Y[Temp_DOWN] = BOX_Y[Temp_DOWN] - 1;
                        if(BOX[Temp_DOWN].position.y < BLOCK_SIZE * 5/2) {
                            BOX[Temp_DOWN].position.y = BLOCK_SIZE * 5/2;
                            BOX_Y[Temp_DOWN] = 2;
                            Temp_Room[BOX_Y[Temp_DOWN] + 1][BOX_X[Temp_DOWN]][BOX_Z[Temp_DOWN]] = "F";
                            Temp_Room[BOX_Y[Temp_DOWN]][BOX_X[Temp_DOWN]][BOX_Z[Temp_DOWN]] = "B";
                            Offset_BoxY[Temp_DOWN] = 0;
                        }
                        if(Temp_BOX_m >= 0) {
                            Temp_Room[BOX_Y[Temp_DOWN] + 2][BOX_X[Temp_DOWN]][BOX_Z[Temp_DOWN]] = "F";
                            Temp_Room[BOX_Y[Temp_DOWN] + 1][BOX_X[Temp_DOWN]][BOX_Z[Temp_DOWN]] = "B";
                            BOX[Temp_BOX_m].position.x = BOX[Temp_DOWN].position.x;
                            BOX[Temp_BOX_m].position.y = BOX[Temp_DOWN].position.y + BLOCK_SIZE;
                            BOX[Temp_BOX_m].position.z = BOX[Temp_DOWN].position.z;
                            BOX_X[ Temp_BOX_m ] = BOX_X[ Temp_DOWN ];
                            BOX_Y[ Temp_BOX_m ] = BOX_Y[ Temp_DOWN ] + 1;
                            BOX_Z[ Temp_BOX_m ] = BOX_Z[ Temp_DOWN ];
                        }
                        Temp_DOWN = -1;
                    }
                }
            }
            if(Temp_DOWN < 0) {
                for (var BOX_i = 0; BOX_i < BOX_count; BOX_i ++) {
                    if((BOX_Y[ BOX_i ] > 2) && (Temp_Room[BOX_Y[BOX_i] - 1][BOX_X[BOX_i]][BOX_Z[BOX_i]] == "F")) {
                        Temp_DOWN = BOX_i;
                        moveX = 0;
                        moveZ = 0;
                    }
                    if((BOX_Y[ BOX_i ] > 2) && (Temp_Room[BOX_Y[BOX_i] - 1][BOX_X[BOX_i]][BOX_Z[BOX_i]] == "F") && (Temp_Room[BOX_Y[BOX_i] - 2][BOX_X[BOX_i]][BOX_Z[BOX_i]] == "L")) {
                        Temp_DOWN = BOX_i;
                        moveX = 0;
                        moveZ = 0;
                    }
                }
            }
            if(Temp_DOWN >= 0) {
                moveX = 0;
                moveZ = 0;
            }

// Player's Walk
            character.position.x = x + walk_step * moveX;
            character.position.z = z + walk_step * moveZ;
            character.rotation.y = walk_dir;
        });

// NPC: SIG
        BABYLON.SceneLoader.ImportMesh("", "", NPC_Sig, cena_Mundo, function (mesh_Sig, particleSystems, skeletons) {
            var Sig =  mesh_Sig[0];
            Sig.rotationQuaternion = undefined;
            Sig.scaling = new BABYLON.Vector3(10, 10, 10);
            Sig.position = new BABYLON.Vector3(x, y, z);
            Sig.rotation.y = -90/180 * Math.PI + walk_dir;
            Sig.position.y = -1 * Offset_Bobj;
            shadowGenerator.addShadowCaster(Sig);
            shadowGenerator.getShadowMap().renderList.push(Sig);

            cena_Mundo.registerBeforeRender(function() {
                Sig.position.x = x-5;
                Sig.position.y = y+5;
                Sig.position.z = z+4;
                Sig.rotation.y = walk_dir;
            });
        });
        }
        }
    }
}

// IDLE


// // Enemy
// if(ENEMY_count > 0) {
//     BABYLON.SceneLoader.ImportMesh("", "", enemy_data, cena_Mundo, function (newMeshes3) {
//     ENEMY[ 0 ] = newMeshes3[ 0 ];
//     ENEMY[ 0 ].rotationQuaternion = undefined;
//     ENEMY[ 0 ].position = new BABYLON.Vector3(Enemy_X[ 0 ], Enemy_Y[ 0 ], Enemy_Z[ 0 ]);
//     ENEMY[ 0 ].scaling = new BABYLON.Vector3(0.1, 0.15, 0.1);
//     ENEMY[ 0 ].alpha = 0.5;		// Not Working
// //		    shadowGenerator.addShadowCaster(ENEMY[ 0 ]);
// //		    shadowGenerator.getShadowMap().renderList.push(ENEMY[ 0 ]);
//     if(ENEMY_count > 1) {
//         for(var i = 1; i < ENEMY_count; i++) {
//                 for (var index = 1; index < newMeshes3.length; index++) {
//                     ENEMY[ i ] = newMeshes3[index].createInstance("Enemy" + index);
//             ENEMY[ i ].rotationQuaternion = undefined;
//             ENEMY[ i ].rotation.y = 90/180 * Math.PI * index;
//             ENEMY[ i ].position = new BABYLON.Vector3(Enemy_X[ i ], Enemy_Y[ i ], Enemy_Z[ i ]);
//             ENEMY[ i ].scaling = new BABYLON.Vector3(0.1, 0.1 + Math.random() * 0.1, 0.1);
//             ENEMY[ i ].alpha = 0.5;		// Not Working
// //			    shadowGenerator.addShadowCaster(ENEMY[ i ]);
// //			    shadowGenerator.getShadowMap().renderList.push(ENEMY[ i ]);
//                 }
//         }
//     }

//     cena_Mundo.registerBeforeRender(function() {
//         for(var Temp_E = 0; Temp_E < ENEMY_count; Temp_E ++) {
//         if(Math.random() < 0.01) {
//             var Temp_R = Math.random() * 5;
//             enemyX[ Temp_E ] = 0;
//             enemyZ[ Temp_E ] = 0;
//             if(Temp_R > 1) {
//             enemyX[ Temp_E ] = 1.0;
//             enemyZ[ Temp_E ] = 0;
//             }
//             if(Temp_R > 2) {
//             enemyX[ Temp_E ] = -1.0;
//             enemyZ[ Temp_E ] = 0;
//             }
//             if(Temp_R > 3) {
//             enemyX[ Temp_E ] = 0;
//             enemyZ[ Temp_E ] = 1.0;
//             }
//             if(Temp_R > 4) {
//             enemyX[ Temp_E ] = 0;
//             enemyZ[ Temp_E ] = -1.0;
//             }
//         }
//         var enemy_row_00 = Math.round(((ENEMY[ Temp_E ].position.x - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
//         var enemy_row_01 = Math.round((((ENEMY[ Temp_E ].position.x + limit) - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
//         var enemy_row_02 = Math.round((((ENEMY[ Temp_E ].position.x - limit) - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_X + 4) / 2);
//         var enemy_col_00 = Math.round(((ENEMY[ Temp_E ].position.z - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
//         var enemy_col_01 = Math.round((((ENEMY[ Temp_E ].position.z + limit) - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
//         var enemy_col_02 = Math.round((((ENEMY[ Temp_E ].position.z - limit) - BLOCK_SIZE / 2) / BLOCK_SIZE) + (Maze_size_Z + 4) / 2);
//         var enemy_vrt_00 = Math.round(ENEMY[ Temp_E ].position.y / BLOCK_SIZE);
//         if((enemyX[ Temp_E ] == 1.0) && (Temp_Room[enemy_vrt_00][enemy_row_01][enemy_col_00] == "W")) {
//             enemyX[ Temp_E ] = 0;
//         }
//         if((enemyX[ Temp_E ] == -1.0) && (Temp_Room[enemy_vrt_00][enemy_row_02][enemy_col_00] == "W")) {
//             enemyX[ Temp_E ] = 0;
//         }
//         if((enemyZ[ Temp_E ] == 1.0) && (Temp_Room[enemy_vrt_00][enemy_row_00][enemy_col_01] == "W")) {
//             enemyZ[ Temp_E ] = 0;
//         }
//         if((enemyZ[ Temp_E ] == -1.0) && (Temp_Room[enemy_vrt_00][enemy_row_00][enemy_col_02] == "W")) {
//             enemyZ[ Temp_E ] = 0;
//         }
//         if((enemyX[ Temp_E ] == 1.0) && (Temp_Room[enemy_vrt_00][enemy_row_01][enemy_col_00] == "B")) {
//             enemyX[ Temp_E ] = 0;
//         }
//         if((enemyX[ Temp_E ] == -1.0) && (Temp_Room[enemy_vrt_00][enemy_row_02][enemy_col_00] == "B")) {
//             enemyX[ Temp_E ] = 0;
//         }
//         if((enemyZ[ Temp_E ] == 1.0) && (Temp_Room[enemy_vrt_00][enemy_row_00][enemy_col_01] == "B")) {
//             enemyZ[ Temp_E ] = 0;
//         }
//         if((enemyZ[ Temp_E ] == -1.0) && (Temp_Room[enemy_vrt_00][enemy_row_00][enemy_col_02] == "B")) {
//             enemyZ[ Temp_E ] = 0;
//         }
//         if((enemyX[ Temp_E ] == 1.0) && (Temp_Room[enemy_vrt_00][enemy_row_01][enemy_col_00] == "G")) {
//             enemyX[ Temp_E ] = 0;
//         }
//         if((enemyX[ Temp_E ] == -1.0) && (Temp_Room[enemy_vrt_00][enemy_row_02][enemy_col_00] == "G")) {
//             enemyX[ Temp_E ] = 0;
//         }
//         if((enemyZ[ Temp_E ] == 1.0) && (Temp_Room[enemy_vrt_00][enemy_row_00][enemy_col_01] == "G")) {
//             enemyZ[ Temp_E ] = 0;
//         }
//         if((enemyZ[ Temp_E ] == -1.0) && (Temp_Room[enemy_vrt_00][enemy_row_00][enemy_col_02] == "G")) {
//             enemyZ[ Temp_E ] = 0;
//         }
//         if((enemyX[ Temp_E ] == 1.0) && (enemy_row_01 > Maze_size_X)) {
//             enemyX[ Temp_E ] = -1;
//         }
//         if((enemyX[ Temp_E ] == -1.0) && (enemy_row_02 <= 2)) {
//             enemyX[ Temp_E ] = 1;
//         }
//         if((enemyZ[ Temp_E ] == 1.0) && (enemy_col_01 > Maze_size_Z)) {
//             enemyZ[ Temp_E ] = -1;
//         }
//         if((enemyZ[ Temp_E ] == -1.0) && (enemy_col_02 <= 2)) {
//             enemyZ[ Temp_E ] = 1;
//         }
//         ENEMY[ Temp_E ].position.x = ENEMY[ Temp_E ].position.x + walk_step * enemyX[ Temp_E ] * Math.random() * 0.5;
//         ENEMY[ Temp_E ].position.z = ENEMY[ Temp_E ].position.z + walk_step * enemyZ[ Temp_E ] * Math.random() * 0.5;
//         if((Math.round(x / 4) == Math.round(ENEMY[ Temp_E ].position.x / 4)) && (Math.round(y / BLOCK_SIZE) == Math.round(ENEMY[ Temp_E ].position.y / BLOCK_SIZE)) && (Math.round(z / 4) == Math.round(ENEMY[ Temp_E ].position.z / 4))) {
//             var advancedTexture_04 = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
//             var text4 = new BABYLON.GUI.TextBlock();
//             text4.text = "GAME OVER !";
//             text4.color = "orange";
//             text4.fontSize = 100;
//             advancedTexture_04.addControl(text4);
//             if(Goal_flag == 0) {
//             var music = new BABYLON.Sound('Game_Over', './sound/info-girl1-zannen1.mp3', cena_Mundo, function() {
//                 music.play();
//             });
//             }
//             Goal_flag = 1;
//         }
//         }
//     });
//     });
// }

// Create VirtualJoystick and set z index to be below playgrounds top bar
	
function updateCamera() {
  // Atualiza a posição da câmera para ficar sempre atrás do player
  camera.position.x = character.position.x;
  camera.position.z = character.position.z + 10; // ajuste a distância da câmera do player aqui
  camera.position.y = character.position.y + 5; // ajuste a altura da câmera aqui

  // Atualiza a rotação da câmera para sempre olhar para o player
  camera.rotation.x = 0;
  camera.rotation.y = character.rotation.y;
  camera.rotation.z = 0;
}

// Chame a função updateCamera em cada frame para atualizar a posição da câmera
engine.runRenderLoop(function() {
  updateCamera();
  cena_Mundo.render();
});


    var move_Joystick = new BABYLON.VirtualJoystick(true);
	BABYLON.VirtualJoystick.Canvas.style.zIndex = "4";
    // Render loop for VirtualJoystick
	cena_Mundo.onBeforeRenderObservable.add(()=>{
		moveX=0;
		moveZ=0;
        
        // Teclado
        document.addEventListener("keydown", function(event){
            // Verifica se a tecla pressionada é "A" (esquerda)
            if (event.code === "KeyA") {
                walk_dir = esquerda_dir;
                moveX = 0;
                moveZ = 1;
                walk_step = walk_org;
                // console.log("Tecla A");
            }
            // Verifica se a tecla pressionada é "D" (direita)
            if (event.code === "KeyD") {
                walk_dir = direita_dir
                moveX = 0;
                moveZ = -1;
                walk_step = walk_org;
                // console.log("Tecla D");
            }
            // Verifica se a tecla pressionada é "W" (frente)
            if (event.code === "KeyS") {
                walk_dir = sul_dir;
                moveX = -1;
                moveZ = 0;
                walk_step = walk_org;
                // console.log("S");
            }
            // Verifica se a tecla pressionada é "S" (atrás)
            if (event.code === "KeyW") {
                walk_dir = norte_dir;
                moveX = 1;
                moveZ = 0;
                walk_step = walk_org;
                // console.log("W");
            }
            // // Verifica se a tecla pressionada é "ESPAÇO" (Pular)
            // if (event.code === "Space") {
            //     // moveY = 1;
            //     // idleAnim.begin();
            //     console.log("espaço");
            // }
             // Verifica se a tecla pressionada é "SHIFT ESQUERDA" (Correr)
            //  if (event.code === "ShiftLeft") {
            //     // moveY = 1;
            //     cena_Mundo.stopAnimation(skeleton_Heroi);
            //     // cena_Mundo.beginAnimation(skeleton_Heroi, runRange.from, runRange.to, true);
            //     // console.log("Shift esquerda");
            // }

        

            // Inicia a nova animação
            // jumpAnim.start();
            // runAnim.beginWeightedAnimation();
            // cena_Mundo.beginAnimation(skeleton_Heroi, jumpRange.from+1, jumpRange.to, 0, true);
            
            
            // // Câmera apontando para a esquerda ok
            // if((camera.alpha >= -135 / 180 * Math.PI) && (camera.alpha < -45 / 180 * Math.PI)) { 
            //     console.log("Camera para esquerda..");
            //     if (event.code === "KeyS") {
            //         walk_dir = sul_dir;
            //         moveX = -1;
            //         moveZ = 0;
            //     } else if (event.code === "KeyW") {
            //         walk_dir = norte_dir;
            //         moveX = 1;
            //         moveZ = 0;
            //     } else {
            //         moveX = 0;
            //     }
            //     if (event.code === "KeyD") {
            //         walk_dir = direita_dir
            //         moveX = 0;
            //         moveZ = -1;
            //     } else if (event.code === "KeyA") {
            //         walk_dir = esquerda_dir
            //         moveX = 0;
            //         moveZ = 1;
            //     } else {
            //         moveZ = 0;
            //     }
            // }

            // // Câmera apontando para a direita OK
            // if((camera.alpha >= -45 / 180 * Math.PI) && (camera.alpha < 45 / 180 * Math.PI)) {
            //     console.log("Camera para direita..");
            //     if (event.code === "KeyA") {
            //         walk_dir = esquerda_dir
            //         moveX = 0;
            //         moveZ = -1;
            //     } else if (event.code === "KeyD") {
            //         walk_dir = direita_dir
            //         moveX = 0;
            //         moveZ = 1;
            //     } else {
            //         moveZ = 0;
            //     }
            //     if (event.code === "KeyS") {
            //         walk_dir = norte_dir;
            //         moveX = 1;
            //         moveZ = 0;
            //     } else if (event.code === "KeyW") {
            //         walk_dir = sul_dir;
            //         moveX = -1;
            //         moveZ = 0;
            //     } else {
            //         moveX = 0;
            //     }
            // }

            // // Câmera apontando para cima/baixo
            // if((camera.alpha >= 45 / 180 * Math.PI) && (camera.alpha < 135 / 180 * Math.PI)) {
            //     console.log("Camera para cima/baixo..");
            //     if (event.code === "KeyA") {
            //         walk_dir = norte_dir;
            //         moveX = 1;
            //         moveZ = 0;
            //     } else if (event.code === "KeyD") {
            //         walk_dir = sul_dir;
            //         moveX = -1;
            //         moveZ = 0;
            //     } else {
            //         moveX = 0;
            //     }
            //     if (event.code === "KeyS") {
            //         walk_dir = direita_dir
            //         moveX = 0;
            //         moveZ = 1;
            //     } else if (event.code === "KeyW") {
            //         walk_dir = esquerda_dir
            //         moveX = 0;
            //         moveZ = -1;
            //     } else {
            //         moveZ = 0;
            //     }
            // }
        });
        
        // Joystick Esquerdo
        if(move_Joystick.pressed){
			if(move_Joystick.deltaPosition.x <= -0.5) { // Esquerda (A)
				walk_dir = esquerda_dir
				moveX = 0;
				moveZ = 1;
				walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.x, 2);
			} else if(move_Joystick.deltaPosition.x >= 0.5) { // Direita (D)
				walk_dir = direita_dir
				moveX = 0;
				moveZ = -1;
				walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.x, 2);
			} else {
				moveZ = 0;
			}
			if(move_Joystick.deltaPosition.y <= -0.5) { // Frente (W)
				walk_dir = sul_dir;
				moveX = -1;
				moveZ = 0;
				walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.y, 2);
			} else if(move_Joystick.deltaPosition.y >= 0.5) { // Atrás (S)
				walk_dir = norte_dir;
				moveX = 1;
				moveZ = 0;
				walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.y, 2);
			} else {
				moveX = 0;
			}

            // Câmera apontando para a esquerda
		    if((camera.alpha >= -135 / 180 * Math.PI) && (camera.alpha < -45 / 180 * Math.PI)) { 
                // console.log("Camera para esquerda..");
                if(move_Joystick.deltaPosition.x <= -0.5) { // joystick para a esquerda
                    walk_dir = sul_dir;
                    moveX = -1;
                    moveZ = 0;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.x, 2);
                } else if(move_Joystick.deltaPosition.x >= 0.5) { // joystick para a direita
                    walk_dir = norte_dir;
                    moveX = 1;
                    moveZ = 0;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.x, 2);
                } else {
                    moveX = 0;
                }
                if(move_Joystick.deltaPosition.y <= -0.5) {// joystick para baixo
                    walk_dir = direita_dir
                    moveX = 0;
                    moveZ = -1;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.y, 2);
                } else if(move_Joystick.deltaPosition.y >= 0.5) { // joystick para cima
                    walk_dir = direita_dir
                    moveX = 0;
                    moveZ = 1;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.y, 2);
                } else {
                    moveZ = 0;
                }
		    }

            // Câmera apontando para a direita
		    if((camera.alpha >= -45 / 180 * Math.PI) && (camera.alpha < 45 / 180 * Math.PI)) {
                // console.log("Camera para direita..");
                if(move_Joystick.deltaPosition.x <= -0.5) { //  joystick para a esquerda
                    walk_dir = direita_dir
                    moveX = 0;
                    moveZ = -1;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.x, 2);
                } else if(move_Joystick.deltaPosition.x >= 0.5) { //  joystick para a direita
                    walk_dir = direita_dir
                    moveX = 0;
                    moveZ = 1;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.x, 2);
                } else {
                    moveZ = 0;
                }
                if(move_Joystick.deltaPosition.y <= -0.5) { // joystick para cima
                    walk_dir = norte_dir
                    moveX = 1;
                    moveZ = 0;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.y, 2);
                } else if(move_Joystick.deltaPosition.y >= 0.5) { // joystick para baixo
                    walk_dir = sul_dir;
                    moveX = -1;
                    moveZ = 0;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.y, 2);
                } else {
                    moveX = 0;
                }
		    }

            // Câmera apontando para cima/baixo
		    if((camera.alpha >= 45 / 180 * Math.PI) && (camera.alpha < 135 / 180 * Math.PI)) {
                // console.log("Camera para cima/baixo..");
                if(move_Joystick.deltaPosition.x <= -0.5) {// Esquerda
                    walk_dir = norte_dir
                    moveX = 1;
                    moveZ = 0;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.x, 2);
                } else if(move_Joystick.deltaPosition.x >= 0.5) {// Direita
                    walk_dir = sul_dir;
                    moveX = -1;
                    moveZ = 0;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.x, 2);
                } else {
                    moveX = 0;
                }
                if(move_Joystick.deltaPosition.y <= -0.5) {// Cima
                    walk_dir = direita_dir
                    moveX = 0;
                    moveZ = 1;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.y, 2);
                } else if(move_Joystick.deltaPosition.y >= 0.5) {// Baixo
                    walk_dir = direita_dir
                    moveX = 0;
                    moveZ = -1;
                    walk_step = walk_org * Math.pow(move_Joystick.deltaPosition.y, 2);
                } else {
                    moveZ = 0;
                }
		    }
        }
	});

// Create button to toggle VirtualJoystick overlay canvas
	var btn = document.createElement("button");
	    btn.innerText = "Enable/Disable Joystick";
	    btn.style.zIndex = 10;
	    btn.style.position = "absolute";
	    btn.style.bottom = "50px";
	    btn.style.right = "0px";
	document.body.appendChild(btn);
// Button toggle logic for VirtualJoystick
	btn.onclick = ()=>{
		if(BABYLON.VirtualJoystick.Canvas.style.zIndex == "-1"){
                    BABYLON.VirtualJoystick.Canvas.style.zIndex = "4";
                }else{
                    BABYLON.VirtualJoystick.Canvas.style.zIndex = "-1";
                }
	}
// Dispose button on rerun for VirtualJoystick
cena_Mundo.onDisposeObservable.add(()=>{
            document.body.removeChild(btn);
});

// if (Goal_flag == 0){
//     executaVideo("assets/videos/Trofeu_1.mp4");
//     console.log("Chegou no objetivo: ");
//     console.log(Goal_flag);
// }

var beforeRenderFunction = function () {
    // camera.lowerBetaLimit = 0.1;			// Moving Limit for Camera
    // camera.upperBetaLimit = (Math.PI / 2) * 0.9;
    // camera.lowerRadiusLimit = 10;
    // camera.upperRadiusLimit = 1500;
    camera.attachControl(canvas, true);

    // Comemoração ao chegar no objetivo
    if((Math.floor(x / BLOCK_SIZE) == Math.floor(Goal_x / BLOCK_SIZE)) && (Math.floor(y / BLOCK_SIZE) == Math.floor(Goal_y / BLOCK_SIZE)) && (Math.floor(z / BLOCK_SIZE) == Math.floor(Goal_z / BLOCK_SIZE))) {
        var advancedTexture_03 = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
        var text1 = new BABYLON.GUI.TextBlock();
        text1.text = "Parabéns!!";
        text1.color = "green";
        text1.fontSize = 150;
        advancedTexture_03.addControl(text1);
        if(Goal_flag == 0) {
            var music = new BABYLON.Sound('Goal', './assets/sounds/effects/sino.mp3', cena_Mundo, function() {
            music.play();
        });
        }
        Goal_flag = 1;
    }
    if (Goal_flag){
        // executaVideo("assets/videos/Trofeu_1.mp4");
        console.log("Chegou no objetivo: ");
    }

    // Vai para 
    if (Goal_flag){
        // executaVideo("assets/videos/viajando_Tempo.mp4");
        console.log("Carregando nova fase...");
        init();
    }
};

cena_Ativa = cena_Mundo;

// trocaCena();

cena_Mundo.registerBeforeRender(beforeRenderFunction);
	return cena_Mundo;
}

var cria_Tarefa = function () {

    // This creates and positions a free camera (non-mesh)
    var camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 1, -10), cena_Tarefa);

    // This attaches the camera to the canvas
    camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), cena_Tarefa);

    // Default intensity is 1. Let's dim the light a small amount
    light.intensity = 0.7;

    // Our built-in 'sphere' shape.
    var sphere = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 2, segments: 32}, cena_Tarefa);

    // Move the sphere upward 1/2 its height
    sphere.position.y = 1;

    cena_Ativa = cena_Tarefa;

    // Our built-in 'ground' shape.
    var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, cena_Tarefa);


    trocaCena();

    
   
	return cena_Tarefa;    
}

// Permite alternar entre as cenas
function trocaCena() {
    if (cena_Ativa === cena_Mundo) {
        cena_Mundo.dispose(); // Limpa os recursos da cena (meshes, luzes, etc) antes de alternar para uma nova cena
        cena_Ativa = cena_Tarefa;
        console.log("Cena Tarefa ativa");
    } else {
        cena_Tarefa.dispose();
        cena_Ativa = cena_Mundo;
        console.log("Cena Mundo ativa");
    }
}

//#  Executa vídeo automaticamente
function executaVideo(video) {
    var tela_Opts = {
        height: 80,
        width: 100,
        sideOrientation: BABYLON.Mesh.DOUBLESIDE
    };

    var Video = BABYLON.MeshBuilder.CreatePlane("tela", tela_Opts, cena_Mundo);
    Video.position = new BABYLON.Vector3(0, 0, 0.1);

    var Video_Material = new BABYLON.StandardMaterial("m", cena_Mundo);
    var Video_Textura = new BABYLON.VideoTexture("vidtex", video, cena_Mundo);
    // var abertura_VideoTex = new BABYLON.VideoTexture("vidtex",video",
    //  cena_Mundo, false, false, {autoplay: false, loop: false, playsinline: false, poster: "https://peach.blender.org/wp-content/uploads/title_anouncement.jpg?x11217"}
    // );
    Video_Material.diffuseTexture = Video_Textura;
    Video_Material.roughness = 1;
    Video_Material.emissiveColor = new BABYLON.Color3.White();
    Video.material = Video_Material;


    // Executa vídeo ao clicar na tela do vídeo
    cena_Mundo.onPointerObservable.add(function (evt) {
        if (evt.pickInfo.pickedMesh === Video) {
            console.log("Clicou no vídeo.");
            if (Video_Textura.video.paused)
                Video_Textura.video.play();

            else
                Video_Textura.video.pause();
            console.log(Video_Textura.video.paused ? "pause" : "executando");
        }
    }, BABYLON.PointerEventTypes.POINTERPICK);
    console.log(Video);
}

// Efeito de fumaça ao pressionar a tecla S
function fumaceia(event, lava){
    if(event.keyCode == 83){ 
        BABYLON.ParticleHelper.CreateAsync("smoke", cena_Mundo).then((set) => {
            set.systems.forEach(s => {
                s.disposeOnStop = true;
            });
            set.start();
        });
        // lava[0].dispose();
    }
}

// Efeito de chuva ao pressionar a tecla c
function chove(event){
    if(event.keyCode == 67){ 
        BABYLON.ParticleHelper.CreateAsync("rain", cena_Mundo).then((set) => {
            set.systems.forEach(s => {
                s.disposeOnStop = true;
            });
            set.start();
            if (som_Efeitos)//
                var chove = new BABYLON.Sound("chuva", chuva, cena_Mundo, null, { loop: false, autoplay: true });
            });
    }
}

// Efeito de explosão ao pressionar a tecla E
function explode(event){
    if(event.keyCode == 69){ 
        BABYLON.ParticleHelper.CreateAsync("explosion", cena_Mundo).then((set) => {
            set.systems.forEach(s => {
                s.disposeOnStop = true;
            });
            set.start();
            if (som_Efeitos)
                var explode = new BABYLON.Sound("explosao", explosao, cena_Mundo, null, { loop: false, autoplay: true });
        });
    }
}

// Efeito de explosão automático
function explode_(){
    BABYLON.ParticleHelper.CreateAsync("explosion", cena_Mundo).then((set) => {
        set.systems.forEach(s => {
            s.disposeOnStop = true;
        });
        set.start();
        if (som_Efeitos)
            var explode = new BABYLON.Sound("explosao", explosao, cena_Mundo, null, { loop: false, autoplay: true });
    });
}

// Efeito de chamas ao pressionar a tecla F
function queima(event){
    if(event.keyCode == 70){ 
        BABYLON.ParticleHelper.CreateAsync("fire", cena_Mundo).then((set) => {
            set.systems.forEach(s => {
                s.disposeOnStop = true;
            });
            set.start();
            if (som_Efeitos)
                var queima = new BABYLON.Sound("fogo", fogo, cena_Mundo, null, { loop: false, autoplay: true });
        });
    }
}

// Efeito de chamas automático
function queima_(){
        BABYLON.ParticleHelper.CreateAsync("fire", cena_Mundo).then((set) => {
            set.systems.forEach(s => {
                s.disposeOnStop = true;
                // s.position = new BABYLON.Vector3(15, 2, 0);
            //    s.maxLifeTime = 2;
                s.isVisible = false;
            });
            set.start();
            // s.dispose(); // Tem que colocar um time antes de desaparecer
            if (som_Efeitos)
                var queima = new BABYLON.Sound("fogo", fogo, cena_Mundo, null, { loop: false, autoplay: true });
        });
}

// Efeito de partículas nas esferas
function geraParticulas(texture, position) {
    // Cria um sistema de partículas
    const origem_ParticleSystem = new BABYLON.ParticleSystem("particles", 25);

    // Textura de cada partícula
    origem_ParticleSystem.particleTexture = new BABYLON.Texture(texture);

    // Posição de onde as partículas são emitidas
    origem_ParticleSystem.emitter = position;

    // Gera e emite as partículas
    origem_ParticleSystem.start();
}

// Permite adicionar partículas de efeito
function adicionaParticulas() {

    // Emissor das partículas
    var emissor = BABYLON.Mesh.CreateBox("emissor", 0.1, cena_Mundo);
    emissor.isVisible = false;

    // Custom shader for particles
    BABYLON.Effect.ShadersStore["myParticleFragmentShader"] =
        "#ifdef GL_ES\n" +
        "precision highp float;\n" +
        "#endif\n" +

        "varying vec2 vUV;\n" + // Provided by babylon.js
        "varying vec4 vColor;\n" + // Provided by babylon.js

        "uniform sampler2D diffuseSampler;\n" + // Provided by babylon.js
        "uniform float time;\n" + // This one is custom so we need to declare it to the effect

        "void main(void) {\n" +
        "vec2 position = vUV;\n" +

        "float color = 0.0;\n" +
        "vec2 center = vec2(0.5, 0.5);\n" +

        "color = sin(distance(position, center) * 10.0+ time * vColor.g);\n" +

        "vec4 baseColor = texture2D(diffuseSampler, vUV);\n" +

        "gl_FragColor = baseColor * vColor * vec4( vec3(color, color, color), 1.0 );\n" + "}\n" + "";

    // Effect
    var effect = engine.createEffectForParticles("myParticle", ["time"]);

    // Particles
    var particleSystem = new BABYLON.ParticleSystem("particles", 40, cena_Mundo, effect);
    particleSystem.particleTexture = new BABYLON.Texture("assets/textures/flare.png", cena_Mundo);
    particleSystem.minSize = 0.1;
    particleSystem.maxSize = 0.5;
    particleSystem.minLifeTime = 0.5;
    particleSystem.maxLifeTime = 5.0;
    particleSystem.minEmitPower = 0.5;
    particleSystem.maxEmitPower = 3.0;
    particleSystem.emitter = emissor;
    particleSystem.emitRate = 50;
    particleSystem.blendMode = BABYLON.ParticleSystem.BLENDMODE_ADD;
    particleSystem.direction1 = new BABYLON.Vector3(-1, 1, -1);
    particleSystem.direction2 = new BABYLON.Vector3(1, 1, 1);
    particleSystem.color1 = new BABYLON.Color4(1, 1, 0, 1);
    particleSystem.color2 = new BABYLON.Color4(1, 0.5, 0, 1);
    particleSystem.gravity = new BABYLON.Vector3(0, -2, 0);
    particleSystem.start();

    var time = 0;
    var order = 0.1;

    effect.onBind = function () {
        effect.setFloat("time", time);

        time += order;

        if (time > 100 || time < 0) {
            order *= -1;
        }
    };
}

// Permite dar zoom no cenário
function zoomIn(cam, tar) {
    var targetEndPos = tar.getAbsolutePosition();
    var speed = 25;
    var ease = new BABYLON.CubicEase();
    tar.computeWorldMatrix();
    var matrix = tar.getWorldMatrix(true);
    var local_position = new BABYLON.Vector3(0,-10,-15);
    local_position.addInPlace(new BABYLON.Vector3(0, -2, -10));
    var global_position = BABYLON.Vector3.TransformCoordinates(local_position, matrix);
    console.log(global_position);
    
    BABYLON.Animation.CreateAndStartAnimation('at4', cam, 'position', speed, 120, cam.position, global_position, 0, ease);
    BABYLON.Animation.CreateAndStartAnimation('at5', cam, 'target', speed, 120, cam.target, targetEndPos, 0, ease);
};

function zoomOut(cam, tar) {
    var targetEndPos = tar.getAbsolutePosition();
    var speed = 25;
    var ease = new BABYLON.CubicEase();
    tar.computeWorldMatrix();
    var matrix = tar.getWorldMatrix(true);
    var local_position = new BABYLON.Vector3(0,0,0);
    local_position.addInPlace(new BABYLON.Vector3(0, 0, -80));
    var global_position = BABYLON.Vector3.TransformCoordinates(local_position, matrix);
    console.log(global_position);
    
    BABYLON.Animation.CreateAndStartAnimation('at4', cam, 'position', speed, 120, cam.position, global_position, 0, ease);
    BABYLON.Animation.CreateAndStartAnimation('at5', cam, 'target', speed, 120, cam.target, targetEndPos, 0, ease);
};

// # Cria a luz e a atmosfera
function createSkyboxAndLight() {
    // Define a general environment texture
    hdrTexture = BABYLON.CubeTexture.CreateFromPrefilteredData("assets/textures/environment.dds", cena_Mundo);
    cena_Mundo.environmentTexture = hdrTexture;

    // Let's create a color curve to play with background color
    var curve = new BABYLON.ColorCurves();
    curve.globalHue = 10;
    curve.globalDensity = 10;

    var box = cena_Mundo.createDefaultSkybox(hdrTexture, true, 200, 0.7);
    box.infiniteDistance = false;
    box.material.imageProcessingConfiguration = new BABYLON.ImageProcessingConfiguration();
    box.material.cameraColorCurvesEnabled = true;
    box.material.cameraColorCurves = curve;
    box.name = "MYMESHFORSKYBOX";
    box.isPickable = false;

    directionalLight = new BABYLON.DirectionalLight('light', new BABYLON.Vector3(-0.2, -1, 0), cena_Mundo)
    directionalLight.position = new BABYLON.Vector3(100 * 0.2, 100 * 2, 0)
    directionalLight.intensity = 4.5;

    // Cria a ATMOSFERA # TROCAR POR UM CÉU NOTURNO
    var skybox = BABYLON.Mesh.CreateBox("BackgroundSkybox", 500, cena_Mundo, undefined, BABYLON.Mesh.BACKSIDE);
    var skyboxMaterial = new BABYLON.BackgroundMaterial("backgroundMaterial", cena_Mundo);
    // skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("assets/skybox/TropicalSunnyDay", cena_Mundo);
    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("assets/skybox/Cerebro", cena_Mundo);
    // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets/skybox/1.hdr", cena_Mundo, 512);
    // skyboxMaterial.reflectionTexture = new BABYLON.HDRCubeTexture("assets/skybox/nebulaSky", cena_Mundo, 512);
    
    //textures/forest.hdr

    
    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
    skybox.material = skyboxMaterial;
}

// Permite interagir enquanto pausado
function sleep1(milliseconds) {
    setTimeout(() => { console.log("World!"); }, milliseconds);
}

// Não permite interagir enquanto pausado
function sleep2(milliseconds) {
    const date = Date.now();
    let currentDate = null;
    do {
        currentDate = Date.now();
    } while (currentDate - date < milliseconds);
}

function reconheceFala() {
    // var SpeechRecognition = SpeechRecognition || webkitSpeechRecognition;
    // var SpeechGrammarList = SpeechGrammarList || webkitSpeechGrammarList;
    // var SpeechRecognitionEvent = SpeechRecognitionEvent || webkitSpeechRecognitionEvent
    // var elementos = ['um', 'UM', 'Um', 'green', 'purple', 'red', 'teal', 'white', 'yellow', 'magenta'];
    // var grammar = 'Elementos da gramática: ' + elementos.join(' | ') + ' ;';
    // console.log(grammar);

    // var speechRecognitionList = new SpeechGrammarList();
    // speechRecognitionList.addFromString(grammar, 1);

    // Object for matching colors
    //    const elementoArray = [];
    //    const elementoMatchList = {
    //        white: BABYLON.Color3.White(),
    //        magenta: BABYLON.Color3.Magenta(),
    //        teal: BABYLON.Color3.Teal(),
    //        red: BABYLON.Color3.Red(),
    //        gray: BABYLON.Color3.Gray(),
    //        green: BABYLON.Color3.Green(),
    //        blue: BABYLON.Color3.Blue(),
    //        black: BABYLON.Color3.Black(),
    //        yellow: BABYLON.Color3.Yellow(),
    //        purple: BABYLON.Color3.Purple()
    //    }
    
        
    // Inicia o reconhecimento
    recognition.start();
    
    // recognition.grammars = speechRecognitionList;
    recognition.continuous = false;
    recognition.lang = 'pt-BR'; // Funciona para qualquer língua, independente deste parametro
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;

    // Exibe o resultado reconhecido
    recognition.onresult = function (event) {
        console.log(event.results[0]);
        var elemento = event.results[0][0].transcript;
        
        // quebrar (strip) a string elemento em varias (de acordo com a qtd de elementos sorteados), usando '.' OU ',' OU ' ' como separador

        console.log('Elemento: ' + elemento);
        // console.log('Elemento: ' + elemento[0]);
        // console.log('Elemento: ' + elemento[1]);
        // console.log('Elemento: ' + elemento[0][0]);
        //  Change Confidence textblock content
        textblock_Resposta.text = elemento.toUpperCase();       
    };

    // Finaliza o reconhecimento
    recognition.onspeechend = function () {
        recognition.stop();
        console.log("Reconhecimento finalizado.");
        Button_Falar.isEnabled = true;
        Button_Falar.children[0].text = ">> COMEÇAR <<";
        textblock_Resposta.text = ">> SUA RESPOSTA <<";
    };

    // Caso o que reconheça bata com os elementos sorteados
    recognition.onmatch = function () {
        // # incrementar a pontuação

        
        textblock_Resposta.text = "Parabéns!";     
        // # add síntese de voz
        // # add alerta sonoro 
        console.log("Muito bem! Você conseguiu!!");
        Button_Falar.children[0].text = elemento.toUpperCase();
    };


    // Caso não reconheça o que foi pronunciado
    recognition.onnomatch = function () {
        textblock_Resposta.text = "Palavra desconhecida!";     
        // # add síntese de voz
        // # add alerta sonoro 
        console.log("Não reconheci essa palavra.");
        Button_Falar.children[0].text = "Tentar novamente!";
    };

    recognition.onerror = function (event) {
        console.log("Ocorreu um erro no reconhecimento: " + event.error);
        Button_Falar.isEnabled = true;
        Button_Falar.children[0].text = "Tentar novamente!";
        textblock_Resposta.text = ">> SUA RESPOSTA <<";
    };
    return recognition;
}

	
// Realiza a leitura de textos associados a elementos presentes na cena por meio de sintese
function leituraTexto(box, bola) {
    let synth = window.speechSynthesis;
    let rate = 1;
    let pitch = 1;

    cena_Mundo.onPointerUp = function (evt, pickResult) {
        if (evt.button === 0) {
            if (pickResult.hit) {
                var meshName = pickResult.pickedMesh.name;
                console.log(pickResult.pickedMesh.name);
                if (meshName == "box") {
                    meshName = box.metadata.speech;
                }
                else if (meshName == "bola") {
                    meshName = bola.metadata.speech;
                }

                let msg = new SpeechSynthesisUtterance(meshName);
                let voices = synth.getVoices();
                // console.log(voices); //1; 16; 21
                msg.voice = voices[21];
                msg.rate = rate;
                msg.pitch = pitch;

                // Iniciou a leitura
                msg.onstart = function (e) {
                    pickResult.pickedMesh.renderOverlay = true;
                    pickResult.pickedMesh.overlayColor = BABYLON.Color3.Blue();
                    console.log(meshName);
                };

                // Finalizou a leitura
                msg.onend = function (e) {
                    pickResult.pickedMesh.renderOverlay = false;
                };
                window.speechSynthesis.speak(msg);
            }
        }
    };
}

// Grava em vídeo ao pressionar G, na duração passada como parâmetro
function gravaTela(event) {
    if(event.keyCode == 71){ 
        // Verifique o suporte para gravação
        if (BABYLON.VideoRecorder.IsSupported(engine)) {
            var recorder = new BABYLON.VideoRecorder(engine);
            // recorder.startRecording("tarefa_01_ET.mpeg, tempo");
            // recorder.startRecording("tarefa_01_ET.mp4", tempo);
            // recorder.startRecording("tarefa_01_ET.webm", tempo);
            // Grava e quanto termina emite um aviso
            recorder.startRecording("tarefa_01_ET.webm", 10).then(() => {
                alert("Gravação concluída!");
            });
        }  
    }
}

// Contrói a Elipse em torno do objeto 
function drawEllipsoid(mesh) {
    mesh.computeWorldMatrix(true);
    var ellipsoidMat = mesh.getScene().getMaterialByName("__ellipsoidMat__");
    if (! ellipsoidMat) { 
        ellipsoidMat = new BABYLON.StandardMaterial("__ellipsoidMat__", mesh.getScene());
        ellipsoidMat.wireframe = true;
        ellipsoidMat.emissiveColor = BABYLON.Color3.Green();
        ellipsoidMat.specularColor = BABYLON.Color3.Black();
    }
    var ellipsoid = BABYLON.Mesh.CreateSphere("__ellipsoid__", 9, 1, mesh.getScene());
    ellipsoid.scaling = mesh.ellipsoid.clone();
    ellipsoid.scaling.y *= 2;
    ellipsoid.scaling.x *= 2;
    ellipsoid.scaling.z *= 2;
    ellipsoid.material = ellipsoidMat;
    ellipsoid.parent = mesh;
    ellipsoid.position = mesh.ellipsoidOffset.clone();
    ellipsoid.computeWorldMatrix(true);
}

// Gera número aleatorio entre um intervalo
var randomNumber = function (min, max) {
    if (min == max) {
        return (min);
    }
    var random = Math.random();
    return ((random * (max - min)) + min);
};

function criaEtiqueta(identificadores, elemento, texto) {
    var etiqueta = new BABYLON.GUI.Rectangle();
    etiqueta.width = 0.1;
    etiqueta.height = "40px";
    etiqueta.cornerRadius = 15;
    etiqueta.color = "Yellow";
    etiqueta.alpha = 0.5;
    etiqueta.thickness = 2;
    etiqueta.background = "green";
    identificadores.addControl(etiqueta);
    etiqueta.linkWithMesh(elemento);
    etiqueta.linkOffsetY = -125; // altura da tag em relação ao elemento

    var label = new BABYLON.GUI.TextBlock();
    label.text = texto;
    // label.color = "Blue";
    etiqueta.addControl(label);

    var target = new BABYLON.GUI.Ellipse();
    target.width = "25px";
    target.height = "25px";
    target.color = "Yellow";
    target.alpha = 0.5;
    target.thickness = 5;
    target.background = "green";
    identificadores.addControl(target);
    target.linkWithMesh(elemento);

    var line = new BABYLON.GUI.Line();
    line.lineWidth = 3;
    line.color = "Yellow";
    line.y2 = 20;
    line.linkOffsetY = -13;
    identificadores.addControl(line);
    line.linkWithMesh(elemento);
    line.connectedControl = etiqueta;
    return target;
}

// Efeito Coletar item (ampulheta, chave, cristal)
// function evento_ColetarItem(player, item, som) {
//     if (player.intersectsMesh(item, true) && item.isVisible) {
//         som(); // troca um efeito sonoro
//         item.dispose();
//         item.isVisible = false;
//         console.log(player.name + ' coletou o ' + item.name);
//     }
// }

// Efeito ao Colidir com bloco (parede, portal)
function evento_Colidir(player, bloco, efeito) {
    if (player.intersectsMesh(bloco, true) && bloco.isVisible) {
        // efeito(); // efeito de acordo como o tipo de bloco
        bloco.material.emissiveColor = new BABYLON.Color3(0, 0, 1);
        bloco.material.alpha = 1;
        console.log(player.name + ' colidiu no ' + bloco.name);
    }
}

// Efeito ao Colidir com NPC
// function evento_Colidir(player, npc, video) {
//     if (player.intersectsMesh(npc, true) && npc.isVisible) {
//         // video();
//         // npc.material.emissiveColor = new BABYLON.Color3(0, 0, 1);
//         console.log(player.name + ' encontrou o(a) ' + npc.name);
//     }
// }


// Constrói portais de teletransporte entre dimenssões
function geraPortal(texture, position) {
    // Cria um sistema de partículas
    const origem_ParticleSystem = new BABYLON.ParticleSystem("particles", 25);

    // Textura de cada partícula
    origem_ParticleSystem.particleTexture = new BABYLON.Texture(texture);

    // Posição de onde as partículas são emitidas
    origem_ParticleSystem.emitter = position;

    // Gera e emite as partículas
    origem_ParticleSystem.start();
}


//Refatorar para passar o objeto como parâmetro
function control_Player(skeleton_Heroi, cena_Mundo){
    
    // var mesh_Heroi = mesh_Heroi[0];// Juntas
    var mesh_Heroi = mesh_Heroi[1]; // Corpo

    // skeleton_Heroi.position = new BABYLON.Vector3(2, 4, -8);
    mesh_Heroi.position = new BABYLON.Vector3(0, 0, 0);
    var t = 0;
    var j = 0;
    var novoValor = 0;
    
    pegar = function(p){
        j = p;
    };
    
    cena_Mundo.beforeRender = function(){
        t += .1;
        if(j != 0){
            // skeleton_Heroi.rotation = new BABYLON.Vector3(0, 0, j[4].x * (5));
            mesh_Heroi.rotation = new BABYLON.Vector3(0, 0, j[4].x * (5));
        }
    };
}

//-----------------Início do MediaPipe---------------------------------
const videoInput = document.getElementsByClassName('input_video')[0];
const canvasOutput = document.getElementsByClassName('output_canvas')[0];
// const canvasCtx = canvasOutput.getContext('3d');

function onResults(results) {
    // canvasCtx.save();
    if (results.multiHandLandmarks) {
        for (const landmarks of results.multiHandLandmarks) {

            // Pega os pontos
            pegarPontos(landmarks);
            ponto = landmarks;
          
            // Desenha os contornos
            // drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
            // drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });
        }
    }
    // canvasCtx.restore();
}
const hand = new Hands({
    locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }
});

hand.setOptions({
    selfieMode: true,
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5,
});

hand.onResults(onResults);

const cameraPlayer = new Camera(videoInput, {
    onFrame: async () => {
        await hand.send({ image: videoInput });
    },
    width: 310,
    height: 180
});

// Inicializar a camera do player
// cameraPlayer.start();

 function pegarPontos(pontos) {
     window.pegar(pontos);
     console.log("Pontos: ", pontos);
}
//-----------------Fim do MediaPipe---------------------------------

function slow() {
	walk_org = 0.2;
	walk_step = 0.2;
	up_step = walk_step + 0.2;
	down_step = walk_step + 0.2;
}
function medium() {
	walk_org = 0.3;
	walk_step = 0.3;
	up_step = walk_step + 0.2;
	down_step = walk_step + 0.2;
}
function fast() {
	walk_org = 0.5;
	walk_step = 0.5;
	up_step = walk_step + 0.2;
	down_step = walk_step + 0.2;
}

// window.initFunction = async function () {
//     var asyncEngineCreation = async function () {
//         try {
//             return createDefaultEngine();
//         } catch (e) {
//             console.log("the available createEngine function failed. Creating the default engine instead");
//             return createDefaultEngine();
//         }
//     }

//     window.engine = await asyncEngineCreation();
//     if (!engine) throw 'engine should not be null.';
//     startRenderLoop(engine, canvas);
//     window.scene = create_Mundo();
// };
// initFunction().then(() => {
//     sceneToRender = scene
// });

// // Resize
// window.addEventListener("resize", function () {
//     engine.resize();
// });
      </script>

   
   </body>
</html>